---
title: "Treatment for COVID-19: A value of information modeling study"  
output:
  word_document: default
  html_document: default
---

Checklist before running the code:

- Have you created a backup (if you wanted to)?
- Has the correct version of parameters been selected?
- Has the latest dataset for hospitalizations been imported?
- Has the latest dataset been imported to R and modified and saved correctly?
- Have the correct end and start dates for hospitalizations been selected?
- Has the correct number of iterations for the PA been selected?
- Are any of chunks of code that have been turned to Eval = FALSE that shouldn't be? Note: Some code-chunks have been deactivated as they are only relevant once, but not every time when the full code is re-run. This option is especially relevant when only small (visual) changes have been made that do not require the PA to re-run.
- Which drugs should be included in the final report, and are these enabled for summary tables?
- Do you want to overwrite or load current tables/figures?




## 00 Knitting setup
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "./") # set working directory to the root directory rather than another sub-folder where the RMarkdown file is saved
#Old name: _model_Hospital_ICU_Recovery_Dead_32.Rmd
```

# 00 Clean global environment
```{r, eval = FALSE}
# Clean list
rm(list = ls())
```

# 01 Load packages
```{r, eval = TRUE, echo = FALSE, warning = FALSE, message = FALSE}
if (!require('pacman')) install.packages('pacman'); library(pacman) 
# use this package to conveniently install other packages
p_load("matrixStats", "ggplot2", 
        "scales",  "reshape2",
        "nlme", "mgcv", "BCEA", 
        "inlabru", "devtools",
        "tibble", "tidyverse", "ggpubr",
        "rms", "europepmc", "xaringan", "Rmisc",
        "fmsb", "remotes", "readxl", "plyr", "stats", "triangle",
        "EnvStats", "e1071", "meta","metafor","gridExtra", 
        "here", "dplyr","ellipse", "ggplot2","lazyeval", 
        "igraph", "ggraph","knitr", "plyr", "stats", "diagram",
        "triangle", "HMDHFDplus", "blscrapeR", "here", "gridExtra", "foreach", "mondate", "parallel", "imguR", "pacman")


# install_github("DARTH-git/dampack", force = TRUE) # Uncomment if there is a newer version
# install_github("DARTH-git/darthpack", force = TRUE) # Uncomment if there is a newer version
# install_github("DARTH-git/darthtools", force = TRUE) # Uncomment if there is a newer version #NOTE! requires the newest devtools and R version 
# devtools::install_github("collectivemedia/tictoc") # install to measure the time

p_load_gh("DARTH-git/dampack") # coding framework to construct model-based cost-effectiveness analysis in R
p_load_gh("DARTH-git/darthpack") # package for analyzing and visualizing the health economic outputs of mathematical models
p_load_gh("DARTH-git/darthtools") # a R package that contains tools frequently used by the DARTH workgroup
#p_load_gh("collectivemedia/tictoc") # package to measure the time of an analysis 

```


# 02 Load functions
```{r, eval = TRUE, echo = FALSE, warning = FALSE, message = FALSE}
#source("../functions/00_general_functions.R")       # general functions
# General functions are now in darthtools
source("../functions/00_general_mycolour.R")
source("../functions/00_general_format_table_function.R")
source("../functions/01_model_input_data_hospitalization_functions.R") # functions for the model
source("../functions/01_model_inputs_functions.R")  # functions for the data
source("../functions/02_decision_model_functions.R") # functions for model structure & to run the model 
source("../functions/02_decision_model_plot_functions.R") # plot functions
source("../functions/02_decision_model_calcout_functions.R") # the entire model
source("../functions/05a_probabilistic_analysis_functions.R")   # functions for the PSA
source("../functions/06_VOI_functions.R")   # functions for the VOI
source("../functions/06_VOI_ENB_functions.R")

```

# 03 Input parameters 
## 03.1 External 
```{r, eval = TRUE}
#### Load data ####
param       <- data.frame(readxl::read_xlsx("../data/parameters_29_submit.xlsx", sheet = "cohort")) # Parameters relating to the study population
param_trt   <- data.frame(readxl::read_xlsx("../data/parameters_29_submit.xlsx", sheet = "Rx")) # Parameters relating to treatment

df_r_HD     <- read.csv("../data/USA_Mx_1x1_2017.csv", sep = ",")

# df_trials_NMA <- data.frame(readxl::read_xls("../data/data_files_upload_covid_nma_database_2021-03-03.xls")) # Uncomment if interested in reviewing new emerging trials registry

```

### 03.1.1 Load new hospital data if a new updated file exists
```{r, eval = TRUE}
# Download latest file from http://www.healthdata.org/covid/data-downloads and save in data folder. Last update: November 2021
# Dataset for hospitalization: Reference_hospitalization_all_locs.csv [current projection]
param_hosp  <- read.csv("../data/reference_hospitalization_all_locs.csv", sep = ",") # Parameters relating to treatment 
save(   param_hosp, file = "../data/param_hosp.rda" )
saveRDS(param_hosp, file = "../data/param_hosp.rds" )

```


### 03.1.2 Remove parameters without unit
```{r}
# Use the function to remove the values without a unit
param     <- remove_param_without_unit(df_param = param)
param_trt <- remove_param_without_unit(df_param = param_trt)

# This step is relevant to remove for example empty rows in the datafile that make the file more readable in Excel
```

### 03.1.3  Save copy of parameters for PA (also known as PSA)
```{r}
# This copy is required as the base code edits param according to the required treatment, whether the PA uses the original input data again.
param_psa_input     <- param
param_trt_psa_input <- param_trt
```

### 03.1.4  Number of hospitalizations
```{r, eval = TRUE}
# Use latest IHME dataset
df_hosp_usa <- modify_df_hospitalization(df_hospitalisation = param_hosp, country = "United States of America")

# Mean daily hospital and ICU admissions
summary(df_hosp_usa$new_ICU_mean ) # ICU - no data for the USA
summary(param_hosp$newICU_mean)    # ICU - check other locations - there are values for other countries, so US data cannot be used

# Plot projected number of hospitalizations USA over time
df_hosp_usa$date <- as.Date(df_hosp_usa$date)

# Plot projected hospitalizations including upper and lower bound USA 
projected_hosp <- ggplot() + 
  geom_path(data = df_hosp_usa, aes(x = date, y = admis_mean, group = location_name), color = "black") +
  geom_path(data = df_hosp_usa, aes(x = date, y = admis_lower, group = location_name), color = "blue", linetype = "dotted") +
  geom_path(data = df_hosp_usa, aes(x = date, y = admis_upper, group = location_name), color = "blue", linetype = "dotted") +
  labs( x = "date", y = "Number of hospitalizations per day", title = "New hospitalizations per day")   + 
  scale_x_date(date_breaks = "1 month", labels = date_format("%m-%Y"))   + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) 

ggsave(path = here("../figures"), filename = paste("Projected number of new hospitalizations per day IHME.png", sep =""))

# Print plot
projected_hosp

# Check from and  until which date the projections are carried out
head(df_hosp_usa$date) # From 2020-02-04 onward
tail(df_hosp_usa$date) # 

# Sum total hospitalizations
sum(df_hosp_usa$admis_mean) # Total hospitalizations as projected over total period


# Specify start and end count
startcount       <- "2021-11-01" #Sys.Date()
endcount         <- max(df_hosp_usa$date)  # The latest data with predictions 
startcount_trial <- startcount
endcount_trial   <- as.Date(mondate(startcount) + 3)  #Start in 1 month, as future patients + current patients are added 

l_hosp_trial <- calculate_hospitalizations(df_hospitalisation = df_hosp_usa, 
                                           startcount = startcount_trial, 
                                             endcount = endcount_trial) # 1 month

l_hosp       <- calculate_hospitalizations(df_hospitalisation = df_hosp_usa, 
                                     startcount = endcount_trial, # continue from the end of trail
                                     endcount   = endcount) 

# Add new numbers into param
param_trt$Med[which(param_trt$Param == "n_H_year")]       <- l_hosp$pop_mean
param_trt$Lo_alpha[which(param_trt$Param == "n_H_year")]  <- l_hosp$pop_lower
param_trt$Hi_beta[which(param_trt$Param == "n_H_year")]   <- l_hosp$pop_upper


param_trt$Med[which(param_trt$Param == "n_H_trial")]       <- l_hosp_trial$pop_mean
param_trt$Lo_alpha[which(param_trt$Param == "n_H_trial")]  <- l_hosp_trial$pop_lower
param_trt$Hi_beta[which(param_trt$Param == "n_H_trial")]   <- l_hosp_trial$pop_upper

# See whether overwriting was successful
param_trt[param_trt$Param == "n_H_year", ]
param_trt[param_trt$Param == "n_H_trial", ]
```


### 03.1.5  Input parameters copy for PSA
```{r}
# This copy is required as the base code edits param according to the required treatment, whether the PSA uses the original input data again.
param_psa_input <- param
param_trt_psa_input <- param_trt
```


### 03.1.6 Substract names 
```{r}
l_names <- list()
l_names$names_notrt <- names_notrt<- sort(unique(param$Treatment))  # subtract the treatment names and order them in alphabetic order 
l_names$names_treatment <- names_treatment<- sort(unique(param_trt$Treatment))  # subtract the treatment names and order them in alphabetic order 
l_names$names_trt <- names_trt <- v_names_trt <- names_treatment[-(names_treatment == "All")] # names of the treatments without the parameters that are applicable for all 
save(v_names_trt, file = "../output/v_names_trt.rda")

# The county data is not used in the analysis at this moment in time. In future analyses we may consider adding additional perspectives.
l_names$names_countries     <- names_countries <- sort(unique(param$Country))  # select the country names
l_names$names_countries_trt <- names_countries_trt <- sort(unique(param_trt$Country)) # select the country names


# Select the parameters of interest for the reporting
# Please note -> needs to be update if the order changes
# l_names$v_names_trt_report <- v_names_trt[c(1:5, 8, 9)]  # Select values when the excel has more treatments than needed
l_names$v_names_trt_report <- v_names_trt
v_names_trt_report_full <- l_names$v_names_trt_report

l_names$v_names_trt_report_full <- as.vector(sapply(l_names$v_names_trt_report, remove_date_from_name))
#l_names$v_names_trt_report_full[[7]] <- substr(l_names$v_names_trt_report_full[[7]], start=1, stop = 11)
# Treatments were saved in the excel with specific dates to allow comparison of specific treatments as more evidence becomes available over time. In the current paper, we only demonstrate one result per treatment option.

save(l_names, file = "../output/l_names.rda") # save the list with all the treatment names
```


### 03.1.7  Load cohort data into environment
```{r}
# Get the median parameter values from the usual care/cohort into the R environment

l_param     <- split_df_to_lists_mean_param(df_param = param)
l_param_all <- split_df_to_lists_mean_param(df_param = param_trt) # run the function 

# Merge all the parameters from one specific treatment/to all the drug specific lists.
# For example some treatment specific values are relevant for all drugs. This is indicated by the # "All" meaning apply to all. 
l_param_trt <- combine_lists(list = l_param_all, combine = "All")

for (n in names(l_param_trt)){
l_param_trt[[n]] <- c(l_param_trt[[n]], l_param$usual_care)
}

``` 

### 03.1.7 Define treatment effect type 
```{r}
# The model allows for Relative Risk, Risk Difference, Odds Ratio or Hazard Ratio treatment effects on mortality, compared to usual care, to be investigated. This code chunk recognizes which treatment effect type should be applied for each of the treatment options as specified in the param excel sheet.
# Additionally, the code checks whether or not a distinction is made between treatment effect with and without ventilation in the ICU population. If no distinction is specified, treatment effect is applied the same for vent/novent groups

for(n in names(l_param_trt)){
  l_list_f <- c()
  l_list_f <- l_param_trt[[n]]
  
  # Code to select type of parameter
  v_names_param <- names(l_param_trt[[n]])
  
  v_trt_type_name <- c("rr_D_Trt_timespan1", 
                       "rd_D_Trt_timespan1", 
                       "or_D_Trt_timespan1", 
                       "hr_D_Trt_timespan1")
 
   v_trt_type <- c("RR",
                   "RD",
                   "OR",
                   "HR")
  
  # Make a dateframe
  df_trt_type <- as.data.frame(cbind(v_trt_type_name, v_trt_type))
  # select the full name of the treatment type
  name <- v_names_param[ which(v_names_param %in% v_trt_type_name)]
  # match it with the corresponding treatment type
  trt_effect <- df_trt_type$v_trt_type[df_trt_type$v_trt_type_name == name] #
  
    vent <- FALSE  # make a variable that by default is FALSE
  if(trt_effect == "RR" & !is.null(l_list_f$rr_D_Trt_timespan1_vent)){
    vent <- TRUE # if  we have information about ventilation, overwrite
  }
  if(trt_effect == "RD" & !is.null(l_list_f$rd_D_Trt_timespan1_vent)){
    vent <- TRUE
  }
  if(trt_effect == "OR" & !is.null(l_list_f$or_D_Trt_timespan1_vent)){
    vent <- TRUE
  }
  if(trt_effect == "HR" & !is.null(l_list_f$hr_D_Trt_timespan1_vent)){
    vent <- TRUE
  }
  
  
  l_param_trt[[n]]$trt_effect <- trt_effect
  l_param_trt[[n]]$vent       <- vent
  
} #close the loop
```



# 04 Internal general model settings and input
```{r, message = FALSE}

l_input_general <- list(
# Strategy names
v_names_str      = c("notrt",      "trt"), 
v_names_str_full = c("Usual Care", "Treatment"), # Standard of care vs treatment


# Markov model parameters
n_age_max = 120  ,            # max. age for life time horizon analysis
n_DpC   = 73 ,                # days per cycle
n_DpY   = 365  ,              # days per year

v_names_states      = c("H", "R_H", "R_IC", "D"),  # the 4 states of the model: Hospitalized, Recovered from Hospital ward (R_H), Recovered from ICU (R_IC) Dead (D)
v_names_states_full = c("Hospitalized", "Recovered from Hospital ward", "Recovered from ICU", "Dead") ,

v_s_init = c("H" = 1, "R_H" = 0, "R_IC" = 0, "D" = 0), # Initial state distribution
# Effects (alive = 1, dead = 0)
e_H    = 1,
e_I    = 1,
e_R    = 1,
e_R_IC = 1,
e_R_H  = 1,
e_D    = 0,

# Discounting factor
# Equal discount of costs and QALYs of 3%
d_e = 0.03,
d_c = 0.03       
)

# Load the parameters from usual care to the environment
# Those treatment specific will we used in a loop
ls()
list2env(l_input_general, globalenv())     # cohort 
ls()


# Combine the list with general input with all the drug specific info
for (n in names(l_param_trt)){
  l_input_general$df_r_HD <- df_r_HD # Add the df with the mortality rate to the general input
  l_param_trt[[n]] <- c(l_param_trt[[n]], l_input_general)
}


l_param_trt_basecase <- l_param_trt
save(l_param_trt_basecase, file = "../output/l_param_trt_basecase.rda" )
save(l_input_general,      file = "../output/l_input_general.rda")
```


# 05 Markov model
##05.1 Run the markov model using the function

```{r, eval = TRUE}
# Create two lists to store the Cost-effectiveness results for the base case analysis
l_out_ce_base <- l_out_ce_base_return_all <- list()

for (n in names(l_param_trt)){
  # save all the items 
l_out_ce_base_return_all[[n]] <- calculate_cea_output_VOI_COVID(l_list = l_param_trt[[n]], n_wtp = l_param_trt[[n]]$wtp, return_all = TRUE,  verbose = FALSE)

l_out_ce_base[[n]] <- l_out_ce_base_return_all[[n]]$df_ce_combined

}

# Extract data to the global environment 
l_input_general <- estimate_input_general(l_param_trt[[1]])

```

```{r, echo=FALSE, warning=FALSE, error=FALSE, results=FALSE}

ls()
invisible(list2env(l_input_general, globalenv())) # cohort 
ls()
```


## 05.2 Create a state-transition diagram of the cohort model
Model: 
H = Hospitalized in study 
R_H = Recovered from Hospital ward
R_IC = Recovered from ICU
D = Dead  

```{r}
# Make a matrix for the structure of the model
m_P_diag2 <- with(l_out_ce_base_return_all[[1]]$l_param_trt_f, matrix(0, nrow = n_states, ncol = n_states, dimnames = list(v_names_states, v_names_states)))

m_P_diag2["H","R_H"]  = "" 
m_P_diag2["H","R_IC"]  = "" 
m_P_diag2["H","D"]  = "" 
m_P_diag2["R_IC","R_IC"]  = ""
m_P_diag2["R_H","R_H"]  = ""
m_P_diag2["R_IC","D"]  = ""
m_P_diag2["R_H","D"]  = ""
m_P_diag2["D","D"]  = "" 

# The layout of the state-bubbles 
layout.fig2 <- c(1, 2, 1)

# plot the final graph
plotmat(t(m_P_diag2), t(layout.fig2), self.cex = 0.4, curve = 0, arr.pos = 0.7,  
        latex = T, arr.type = "curved", relsize = 0.9, box.prop = 0.7, 
        cex = 0.6, box.cex = 0.9, lwd = 1)


  # 1. Open pgn file
  png(paste("../figures/cohort_state_transition_diagram.png", sep =""))
  
  # plot the final graph
plotmat(t(m_P_diag2), t(layout.fig2), self.cex = 0.4, curve = 0, arr.pos = 0.7,  
        latex = T, arr.type = "curved", relsize = 0.9, box.prop = 0.7, 
        cex = 0.6, box.cex = 0.9, lwd = 1)

    # 3. Close the file
    dev.off()

```

# 06 Compute and Plot Epidemiological Outcomes

## 06.1 Cohort trace

```{r}

# This code is a loop to make the cohort trace plots and save them   
  for (n in names(l_param_trt)){
    # rename the names from the list
    l_trace_plot <- l_out_ce_base_return_all[[n]]$l_trace
    
    # No Treatment Treatment : names in the plot making
    M_trt   <- l_trace_plot$trt
    M_notrt <- l_trace_plot$notrt
  
    # give the columns full names
    colnames(M_trt)   <- v_names_states_full
    colnames(M_notrt) <- v_names_states_full

    ## NO TRT ##
    #create the plot
     PlotTrace2(trace = M_notrt, xlab = "Cycle", title = paste(paste("No Treatment", " ", remove_date_from_name(n), sep ="")))
     
     # Save the plot
    ggsave(path = here("../figures"), filename = paste("Markov Trace", "_", "No Treatment", " ", remove_date_from_name(n), ".png", sep =""))
    
    
    ## TRT ##
     #create the plot
     PlotTrace2(trace = M_trt, xlab = "Cycle", title = paste(paste("Treatment", " ", remove_date_from_name(n), sep ="")))
     
     # Save the plot
    ggsave(path = here("../figures"), filename = paste("Markov Trace", "_",  "Treatment", " ", remove_date_from_name(n), ".png", sep =""))
    
    
    ### Code to export the graph details to Rdata
    plot_markovtrace_no_trt <- PlotTrace2(trace = M_notrt, xlab = "Cycle", title = paste(paste("No Treatment", " ", remove_date_from_name(n), sep ="")))
    
    plot_markovtrace_trt    <- PlotTrace2(trace = M_trt, xlab = "Cycle", title = paste(paste("No Treatment", " ", remove_date_from_name(n), sep ="")))
    
    save(plot_markovtrace_no_trt, file = paste("../output/", "Plot_Markov Trace", "_", "No Treatment", " ", remove_date_from_name(n), ".Rdata", sep =""))
    
    save(plot_markovtrace_trt, file = paste("../output/", "Plot_Markov Trace", "_", "Treatment", " ", remove_date_from_name(n), ".Rdata", sep =""))
    
    
    # Combine the figures # 
    ggarrange(plot_markovtrace_no_trt, plot_markovtrace_trt, 
          labels = c("A", "B"),
          ncol = 2, nrow = 1,
          common.legend = TRUE,
          legend = "bottom")
    
        ggsave(path = here("../figures"), filename = paste("Markov Traces", "_", remove_date_from_name(n), ".png", sep =""))
    
    
    }

```


## 06.2 Overall Survival (OS)

```{r}

# Matrix for the overall survival  
m_os <- with(l_out_ce_base_return_all[[1]]$l_param_trt_f, 
             matrix(data = NA, 
                 nrow = n_t + 1, ncol = length(names(l_param_trt)),
                 dimnames = list(paste("cycle", 0:n_t, sep = " "),
                                 names(l_param_trt)))
             )


# Create a data frame 
df_survival <-  with(l_out_ce_base_return_all[[1]]$l_param_trt_f, 
                     data.frame(treatment = rep(names(l_param_trt), 
                                             each = (n_t + 1) * length(v_names_str)), 
                              strategy = rep(rep(c("trt", "notrt"), 
                                                each = (n_t + 1)), length(names(l_param_trt))),
                                 cycle = rep(rep(0:n_t), 
                                         times = length(names(l_param_trt)) * length(v_names_str)),
                                    OS = NA)  
)
  

l_trace <- c()
for(n in names(l_param_trt)){
  
  v_names_str <-l_out_ce_base_return_all[[1]]$l_param_trt_f$v_names_str
  
    for (k in v_names_str){ # loop for the number or strategies 
  
      l_trace <- l_out_ce_base_return_all[[n]]$l_trace
      l_M     <- l_trace[[k]]
  
      # calculate the overall survival (OS) probability 
      v_os <- 1 - l_M[, "D"]
      
      m_os[, n] <- v_os  # store the vector in the drug specific column 
      
      # create a dataframe with the overall survival
      # Run the function to generate a dataframe of the overall survival
      df_survival$OS[df_survival$treatment == n & df_survival$strategy == k] <- v_os
    }
}
  

# Run the function plot_survival for all the treatments   
  for (n in unique(df_survival$treatment)){
    df_surv_loop <- filter(df_survival, treatment == n)
    
    plot_surv_full <- plot_survival(df_survival = df_surv_loop, cycle_zoom = FALSE)
    plot_surv_full
    ggsave(path = here("../figures"), filename = paste("Overall_survival", "_", remove_date_from_name(n), ".png", sep =""))
    
    plot_surv_zoom <- plot_survival(df_survival = df_surv_loop, cycle_zoom = 5)
    plot_surv_zoom
    ggsave(path = here("../figures"), filename = paste("Overall_survival_start", "_", remove_date_from_name(n), ".png", sep =""))

  }

```

### 06.2.1 Life Expectancy (LE)

```{r}
l_le <- generate_df_life_expectancy(df_survival = df_survival, v_names_str = v_names_str)

# Make figures of the LE
for(n in names(l_param_trt)){
  
      df_le_plot <- l_le$df_le %>% #filter the dataframe
      filter(treatment == n) 
  
  plot <- plot_life_expectancy(df_le_plot)+
        scale_color_manual(values = c(my_red, my_darkgreen, my_black)) + 
    scale_fill_manual(values = c(my_red, my_darkgreen, my_black))# make the plot
  
  ggsave(path = here("../figures"), 
         filename = paste("LE", "_", remove_date_from_name(n), ".png", sep ="")) #save plot
       
}


plot <- ggplot(data = l_le$df_le, aes(x = strategy, y = LE, group = strategy, fill = strategy)) + 
          scale_color_manual(values = c(my_red, my_darkgreen, my_black)) + 
    scale_fill_manual(values = c(my_red, my_darkgreen, my_black)) + # make the plot
    geom_col() +
 facet_wrap(~ treatment) +
    ggtitle(paste("Life expectancy overview")) 

  ggsave(path = here("../figures"), 
         filename = paste("LE_summary.png")) #save plot
      
  
# Subset the report data
df_le_plot_report <- l_le$df_le[l_le$df_le$treatment %in% l_names$v_names_trt_report, ]

# Remove the date from the treatment names 
df_le_plot_report$treatment <- sapply( df_le_plot_report$treatment, remove_date_from_name)
  
plot <- ggplot(data = df_le_plot_report, aes(x = strategy, y = LE, group = strategy, fill = strategy)) + 
          scale_color_manual(values = c(my_red, my_darkgreen, my_black)) + 
    scale_fill_manual(values = c(my_red, my_darkgreen, my_black)) + # make the plot
    geom_col() +
 facet_wrap(~ treatment) +
    ggtitle(paste("Life expectancy overview")) 

  ggsave(path = here("../figures"), 
         filename = paste("LE_summary_report.png")) #save plot
```

# 07 Compute Cost-Effectiveness Outcomes

```{r}
### Cost effectiveness analysis for lifeyears ###
# Our effects are life years and therefore the ICER gives the incremental cost per life year gained.  ICER = $/LY

l_df_results <- l_out_ce_base


l_df_cea <- l_df_cea_QALY <- list()

for (n in names(l_param_trt)){
  
  df_cea <- calculate_icers(cost     = l_df_results[[n]]$Cost,
                          effect     = l_df_results[[n]]$LY,
                          strategies = l_df_results[[n]]$Strategy)
 
  l_df_cea[[n]] <- df_cea
  
### Cost effectiveness analysis for quality of life ###
  # Effects of df_cu is utility, and therefore the ICER gives the incremental cost per utility gained. ICER = $/QALY
  df_cea_QALY <- calculate_icers(cost       = l_df_results[[n]]$Cost,
                                 effect     = l_df_results[[n]]$Effect,
                                 strategies = l_df_results[[n]]$Strategy)
  l_df_cea_QALY[[n]] <- df_cea_QALY
}

### Print and save results LY and QALY ###
# Print all CEA dataframes lifeyears
 l_df_cea_LY <- l_df_cea
 
# Print all CEA dataframes QOL
l_df_cea_QALY

# save the data
save(l_df_cea_QALY, file = "../output/l_df_cea_QALY.rda") 
save(l_df_cea, file = "../output/l_df_cea_LY.rda") 

```


## 07.1 Summary table base case - QALY
```{r}
# Create summary report for manuscript/annex
v_names_column <- c("Cost-effective", 
                     "Incr cost Rx", "Incr effect Rx",
                    "ICER", 
                    "Incr NMB", "Incr NHB")
m_summary_cea_QALY <- matrix(data = NA, 
                             ncol = length(v_names_column) ,
                             nrow = length(names(l_param_trt)),
                             dimnames = list(names(l_param_trt), v_names_column))


# NOTE:
# Yes*  = Trt is dominant
# No*   = Trt is dominated by noTrt
# Yes** = Trt is cost-saving ICER > WTP
# No**  = Trt is cost-saving, but not enough that ICER > WTP

for(n in names(l_param_trt)){
  
  df_summary_f    <- l_df_cea_QALY[[n]]
  df_combined_f   <- l_out_ce_base_return_all[[n]]$df_ce_combined
  
    # Values to always store 
  m_summary_cea_QALY[n, "Incr NMB"] <- df_combined_f$NMB[df_combined_f$Strategy == "trt"] - df_combined_f$NMB[df_combined_f$Strategy == "notrt"]
  m_summary_cea_QALY[n, "Incr NHB"] <- df_combined_f$NHB[df_combined_f$Strategy == "trt"] - df_combined_f$NHB[df_combined_f$Strategy == "notrt"]
  
  # Check if treatment is not dominated or dominant
  if(df_summary_f$Status[df_summary_f$Strategy == "trt"] == "D"){
    m_summary_cea_QALY[n, "Cost-effective"] <- "No*"
    m_summary_cea_QALY[n, "Incr effect Rx"] <- df_summary_f$Effect[df_summary_f$Strategy == "trt"] - df_summary_f$Effect[df_summary_f$Strategy == "notrt"]
    m_summary_cea_QALY[n, "Incr cost Rx"] <- df_summary_f$Cost[df_summary_f$Strategy == "trt"] - df_summary_f$Cost[df_summary_f$Strategy == "notrt"]
    
  } else if (df_summary_f$Status[df_summary_f$Strategy == "notrt"] == "D"){
    m_summary_cea_QALY[n, "Cost-effective"] <- "Yes*"
        m_summary_cea_QALY[n,"Incr effect Rx"] <- df_summary_f$Effect[df_summary_f$Strategy == "trt"] - df_summary_f$Effect[df_summary_f$Strategy == "notrt"]
    m_summary_cea_QALY[n, "Incr cost Rx"]     <- df_summary_f$Cost[df_summary_f$Strategy == "trt"] - df_summary_f$Cost[df_summary_f$Strategy == "notrt"]
    
  } else if(!is.na(df_summary_f$ICER[df_summary_f$Strategy == "trt"]) & df_summary_f$ICER[df_summary_f$Strategy == "trt"] > l_param_trt[[n]]$wtp){
    m_summary_cea_QALY[n, "Cost-effective"] <- "No"
    m_summary_cea_QALY[n, "ICER"         ] <- df_summary_f$ICER[df_summary_f$Strategy       == "trt"]
    m_summary_cea_QALY[n, "Incr effect Rx"] <- round(df_summary_f$Inc_Effect[df_summary_f$Strategy == "trt"], 3)
    m_summary_cea_QALY[n, "Incr cost Rx" ] <- round(df_summary_f$Inc_Cost[df_summary_f$Strategy   == "trt"])
  } else if(!is.na(df_summary_f$ICER[df_summary_f$Strategy == "trt"]) & df_summary_f$ICER[df_summary_f$Strategy == "trt"] <= l_param_trt[[n]]$wtp){
    m_summary_cea_QALY[n, "Cost-effective"] <- "Yes"
    m_summary_cea_QALY[n, "ICER"] <- df_summary_f$ICER[df_summary_f$Strategy == "trt"]
    m_summary_cea_QALY[n,"Incr effect Rx"] <- df_summary_f$Inc_Effect[df_summary_f$Strategy == "trt"]
    m_summary_cea_QALY[n,"Incr cost Rx"] <- df_summary_f$Inc_Cost[df_summary_f$Strategy == "trt"]
  } else{
    m_summary_cea_QALY[n, "Incr effect Rx"] <- -1 * df_summary_f$Inc_Effect[df_summary_f$Strategy == "notrt"]
    m_summary_cea_QALY[n, "Incr cost Rx"] <- -1 * df_summary_f$Inc_Cost[df_summary_f$Strategy   == "notrt"]
        m_summary_cea_QALY[n, "ICER"] <- df_summary_f$ICER[df_summary_f$Strategy == "notrt"]
    
        if (round(df_summary_f$ICER[df_summary_f$Strategy       == "notrt"]) > l_param_trt[[n]]$wtp) {
    m_summary_cea_QALY[n, "Cost-effective"] <- "Yes**"
        } else { m_summary_cea_QALY[n, "Cost-effective"] <- "No**"}
    
  }
  df_summary_cea_QALY <- as.data.frame(m_summary_cea_QALY)
}


# Create columns that are numeric 
df_summary_cea_QALY[, -1] <- data.frame(lapply(df_summary_cea_QALY[, -1], as.numeric))
# Save the df in the output folder

save(df_summary_cea_QALY, file = "../output/df_summary_cea_QALY.rda")  


# Format the table 
## Full table
df_summary_cea_QALY_plot_order <- format_table_summary(df_summary_cea_QALY)
df_summary_cea_QALY_plot_order[is.na(df_summary_cea_QALY_plot_order)] <- "n/a"

# Save table summary
png("../figures/table_summary_cea_QALY_all.png", width = 2000, height = 380, bg = "white", pointsize = 22)
grid.table(df_summary_cea_QALY_plot_order)
dev.off()


## Subset
df_summary_cea_QALY_report <- format_table_summary(df_summary_cea_QALY, v_names_subset = l_names$v_names_trt_report)


format(df_summary_cea_QALY_report, digits = 3, big.mark   = ",")

#df_summary_cea_QALY_report[is.na(df_summary_cea_QALY_report)] <- "-"

df_summary_cea_QALY_report[is.na(df_summary_cea_QALY_report)] <- "n/a"

png("../figures/table_summary_cea_QALY.png", width = 2000, height = 380, bg = "white", pointsize = 22)
grid.table(format(df_summary_cea_QALY_report, digits = 3, big.mark   =","))
dev.off()



```


## 07.2 Summary table base case - LY
```{r}

v_names_column <- c("Cost-effective", 
                     "Incr cost Rx", "Incr effect Rx",
                    "ICER", 
                    "Incr NMB", "Incr NHB")
m_summary_cea_LY <- matrix(data = NA, 
                             ncol = length(v_names_column) ,
                             nrow = length(names(l_param_trt)),
                             dimnames = list(names(l_param_trt), v_names_column))


# NOTE:
# Yes*  = Trt is dominant
# No*   = Trt is dominated by noTrt
# Yes** = Trt is cost-saving ICER > WTP
# No**  = Trt is cost-saving, but not enough that ICER > WTP

for(n in names(l_param_trt)){
  
  df_summary_f    <- l_df_cea_LY[[n]]
  df_combined_f   <- l_out_ce_base_return_all[[n]]$df_ce_combined
  
    # Values to store always 
  m_summary_cea_LY[n, "Incr NMB"] <- df_combined_f$NMB_LY[df_combined_f$Strategy == "trt"] - df_combined_f$NMB_LY[df_combined_f$Strategy == "notrt"]
  m_summary_cea_LY[n, "Incr NHB"] <- df_combined_f$NHB_LY[df_combined_f$Strategy == "trt"] - df_combined_f$NHB_LY[df_combined_f$Strategy == "notrt"]
  
  # check if treatment is not dominated or dominant
  if(df_summary_f$Status[df_summary_f$Strategy == "trt"] == "D"){
    m_summary_cea_LY[n, "Cost-effective"] <- "No*"
    m_summary_cea_LY[n, "Incr effect Rx"] <- df_summary_f$Effect[df_summary_f$Strategy == "trt"] - df_summary_f$Effect[df_summary_f$Strategy == "notrt"]
    m_summary_cea_LY[n, "Incr cost Rx"] <- df_summary_f$Cost[df_summary_f$Strategy == "trt"] - df_summary_f$Cost[df_summary_f$Strategy == "notrt"]
    
  } else if (df_summary_f$Status[df_summary_f$Strategy == "notrt"] == "D"){
    m_summary_cea_LY[n, "Cost-effective"] <- "Yes*"
        m_summary_cea_LY[n,"Incr effect Rx"] <- df_summary_f$Effect[df_summary_f$Strategy == "trt"] - df_summary_f$Effect[df_summary_f$Strategy == "notrt"]
    m_summary_cea_LY[n, "Incr cost Rx"]     <- df_summary_f$Cost[df_summary_f$Strategy == "trt"] - df_summary_f$Cost[df_summary_f$Strategy == "notrt"]
    
  } else if(!is.na(df_summary_f$ICER[df_summary_f$Strategy == "trt"]) & df_summary_f$ICER[df_summary_f$Strategy == "trt"] > l_param_trt[[n]]$wtp){
    m_summary_cea_LY[n, "Cost-effective"] <- "No"
    m_summary_cea_LY[n, "ICER"         ] <- df_summary_f$ICER[df_summary_f$Strategy       == "trt"]
    m_summary_cea_LY[n, "Incr effect Rx"] <- round(df_summary_f$Inc_Effect[df_summary_f$Strategy == "trt"], 3)
    m_summary_cea_LY[n, "Incr cost Rx" ] <- round(df_summary_f$Inc_Cost[df_summary_f$Strategy   == "trt"])
  } else if(!is.na(df_summary_f$ICER[df_summary_f$Strategy == "trt"]) & df_summary_f$ICER[df_summary_f$Strategy == "trt"] <= l_param_trt[[n]]$wtp){
    m_summary_cea_LY[n, "Cost-effective"] <- "Yes"
    m_summary_cea_LY[n, "ICER"] <- df_summary_f$ICER[df_summary_f$Strategy == "trt"]
    m_summary_cea_LY[n,"Incr effect Rx"] <- df_summary_f$Inc_Effect[df_summary_f$Strategy == "trt"]
    m_summary_cea_LY[n,"Incr cost Rx"] <- df_summary_f$Inc_Cost[df_summary_f$Strategy == "trt"]
  } else{
    m_summary_cea_LY[n, "Incr effect Rx"] <- -1 * df_summary_f$Inc_Effect[df_summary_f$Strategy == "notrt"]
    m_summary_cea_LY[n, "Incr cost Rx"] <- -1 * df_summary_f$Inc_Cost[df_summary_f$Strategy   == "notrt"]
        m_summary_cea_LY[n, "ICER"] <- df_summary_f$ICER[df_summary_f$Strategy == "notrt"]
    
        if (round(df_summary_f$ICER[df_summary_f$Strategy       == "notrt"]) > l_param_trt[[n]]$wtp) {
    m_summary_cea_LY[n, "Cost-effective"] <- "Yes**"
        } else { m_summary_cea_LY[n, "Cost-effective"] <- "No**"}
    
  }
  df_summary_cea_LY <- as.data.frame(m_summary_cea_LY)
}


# make all columns that are numbers numeric 
df_summary_cea_LY[, -1] <- data.frame(lapply(df_summary_cea_LY[, -1], as.numeric))
# Save the df in the output folder

save(df_summary_cea_LY, file = "../output/df_summary_cea_LY.rda")  


# Format the table 
## Full tabel
df_summary_cea_LY_plot_order <- format_table_LY_summary(df_summary_cea_LY)

df_summary_cea_LY_plot_order[is.na(df_summary_cea_LY_plot_order)] <- "n/a"
png("../figures/table_summary_cea_LY_all.png", width = 2000, height = 380, bg = "white", pointsize = 22)
grid.table(df_summary_cea_LY_plot_order)
dev.off()


## Subset
df_summary_cea_LY_report <- format_table_summary(df_summary_cea_LY, v_names_subset = l_names$v_names_trt_report)


format(df_summary_cea_LY_report, digits = 3, big.mark   = ",")

#df_summary_cea_QALY_report[is.na(df_summary_cea_QALY_report)] <- "-"

df_summary_cea_LY_plot_order[is.na(df_summary_cea_LY_plot_order)] <- "n/a"
png("../figures/table_summary_cea_LY.png", width = 2000, height = 380, bg = "white", pointsize = 22)
grid.table(format(df_summary_cea_LY_report, digits = 3, big.mark   =","))
dev.off()



```



# 08 Sensitivity analysis 
Note: All one- and two way sensitivity analysis code chunks have been disabled as eval = FALSE. The code remains added as an example, so that reviewers can investigate specific assumptions as they see fit.

## 08.1 List of input parameters

Create list `l_param_trt_sa` with all input probabilities, cost and utilities but remove the non-numeric items
```{r, eval = FALSE}
l_param_trt_sa <- list()
for (n in names(l_param_trt)){
l_param_trt_sa[[n]] <- remove_non_numeric_list_items(l_param_trt[[n]])
}

```

## 08.2 One-way sensitivity analysis 
```{r, eval = FALSE}
options(scipen = 999) # Disabling scientific notation in R
# Dataframe containing all parameters, their base case values, and the min and 

# Test the function
test <- calculate_cea_output_VOI_COVID(l_param_trt[[1]], n_wtp = l_param_trt[[1]]$wtp,  verbose = FALSE)

# max values of the parameters of interest 
df_params_owsa <- data.frame(pars = c("c_recovery", "c_Healthcare"),
                             min  = c(       0, 0),   # min parameter values
                             max  = c(      5e3, 2e4) # max parameter values
                             )


l_owsa_nmb <- list()

for (n in names(l_param_trt)){
owsa_nmb  <- run_owsa_det(params_range     = df_params_owsa,        # dataframe with parameters for OWSA
                          params_basecase  = l_param_trt[[n]],      # list with all parameters
                          nsamp            = 100,                   # number of parameter values
                          FUN              = calculate_cea_output_VOI_COVID,  # function to compute outputs
                          outcomes         = c("NMB"),              # output to do the OWSA on
                          strategies       = v_names_str,           # names of the strategies
                          n_wtp            = l_param_trt[[n]]$wtp)  # extra argument to pass to FUN

print(n) # print which treatment is done
print( paste( round(which(names(l_param_trt) == n) / length(names(l_param_trt)) * 100, 0), "% Done", sep = "")) # Print which part is done 

l_owsa_nmb[[n]] <- owsa_nmb # Return the values
}


l_owsa_nmb
# save the owsa data output
save(l_owsa_nmb, file = "../output/l_owsa_nmb.rda")  

l_param_trt_sa <- l_param_trt_sa


```


### 08.2.1 Plot OWSA

```{r, eval = FALSE}
# Select treatment of interest to make the plot

for (n in names(l_param_trt)){
owsa_nmb <- l_owsa_nmb[[n]]

# Plot the sensitivity analysis figures
plot(owsa_nmb, txtsize = 10, n_x_ticks = 4, 
     facet_scales = "free") +
     theme(legend.position = "bottom")

ggsave(path = here("../figures"), filename = paste("OWSA", "_", remove_date_from_name(n), ".png", sep =""))  # save the plot


}
```

### 08.3.2 Optimal strategy with OWSA

Only useful if we have more than one strategy to compare.
```{r, eval = FALSE}

df_owsa_opt_strat <- data.frame()  # Make a dataframe without any data 

for (n in names(l_param_trt)){

  owsa_nmb <- l_owsa_nmb[[n]] # select the drug of interest 
  
  # Run the function
  owsa_opt_strat(owsa = owsa_nmb, txtsize = 10, return = "data") # you can also return a plot
  
  # Store the data 
  df_owsa_opt_strat_new <- owsa_opt_strat(owsa = owsa_nmb, txtsize = 10, return = "data") # you can also return a plot  
  
  # Add a column for the treatment name
  df_owsa_opt_strat_new$"Treatment" <- n
  
  print(n) # print which treatment is done
print( paste( round(which(names(l_param_trt) == n) / length(names(l_param_trt)), 2), "% Done", sep = "")) # Print which part is done 

  # Combine the data 
  df_owsa_opt_strat <- rbind(df_owsa_opt_strat, df_owsa_opt_strat_new)
}

# Save the owsa optimal strategy data 
save(df_owsa_opt_strat, file = "../output/df_owsa_opt_strat.rda")  

```

## 08.4 Two-way sensitivity analysis (TWSA)

```{r, eval = FALSE}

# dataframe containing all parameters, their basecase values, and the min and 
# max values of the parameters of interest
df_params_twsa <- data.frame(pars = c("n_Trt", "u_H"),
                             min  = c(0, 0),   # min parameter values
                             max  = c(400, 1)  # max parameter values
                             )

l_twsa_nmb <- list()

for (n in names(l_param_trt)){

  twsa_nmb <- run_twsa_det(params_range  = df_params_twsa,    # dataframe with parameters for TWSA
                         params_basecase = l_param_trt_sa[[n]],      # list with all parameters
                         nsamp           = 10,                # number of parameter values
                         FUN             = calculate_cea_output_VOI_COVID,  # function to compute outputs
                         outcomes        = c("NMB"),          # output to do the TWSA on
                         strategies      = v_names_str,       # names of the strategies
                         n_wtp           = l_param_trt_sa[[n]]$wtp)              # extra argument to pass to FUN

l_twsa_nmb[[n]] <- twsa_nmb
}

```
```{r, eval = FALSE}

# save the twsa data output
save(l_twsa_nmb, file = "../output/l_twsa_nmb.rda")  

```


### 08.4.1 Plot TWSA

Only useful if we have more than one strategies to compare.

```{r, eval = FALSE}

for (n in names(l_param_trt)){
  
  plot(l_twsa_nmb[[n]]) # plot the data 

  n <- names(l_param_trt)[2]ggsave(path = here("./figures"), filename = paste("TWSA", "_", remove_date_from_name(n), ".png", sep = ""))  # save the plot

}
```


# 9 PA
## 9.1 General PA settings
```{r}
seed <- 2020
set.seed(seed)       # set the seed to allow reproduction of results
n_iter <- 10000      # number of iterations for the PA. Note, depending on the computer on which the model is run this can take between 0.5 to 2 hours. For "quick checks" to see whether the model works, we recommend temporarily tuning this number down. For more reliable results, we recommend running (at least) 10000 iterations.   
```

## 9.2 Generate the PA dataset
```{r}
# Print the copy of input parameters as defined earlier in the code
param_psa_input    # the original data for the usual care arm
param_trt <- param_trt_psa_input  # the original data for the treatment arms, including parameters that are relevant for all strategies

# Create lists to store the data frames with PSA data for the different treatments
l_df_param_psa <- l_df_psa <- l_m_Parameters <- list()

# Check loop row by row
# n = names_treatment[1] # use this line to select a specific treatment to check code below

# Create loops to select treatments, create datafame and list for PSA parameters
# This way we split the data for treatments
for (n in names_treatment){
  sub_param_psa <- filter(param_trt, Treatment == n) # Select the values corresponding to each treatment
  assign(paste("df_param_psa_", n, sep = ""), sub_param_psa) # Same in the list name of the treatment
  l_df_param_psa[[n]] <- sub_param_psa
  remove(sub_param_psa) # remove the temporary files 
}

# Create dataframe with parameters values of each run of the PSA 
# This loop makes use of the make_psa_df functions
for (n in names_treatment){ # loop where also "ALL" is included
  df_temporary            <- l_df_param_psa[[n]] # Save df in temp
  param_psa_trt_temporary <- make_psa_df(param = df_temporary, n_iter = n_iter, seed = seed)
  l_df_psa[[n]]           <- param_psa_trt_temporary
  remove(df_temporary)
}

# For general / cohort parameters
#  This code makes use of the make_psa_df function
df_psa_notrt <- make_psa_df(param = param_psa_input, n_iter = n_iter, seed = seed)
# as this is the usual care arm, we will refer to this as 'no treatment' or notrt

for (n in v_names_trt){
  df_temporary     <- l_df_psa[[n]]     # select the parameters for trt
  df_temporary_all <- l_df_psa[["All"]] # select those that belong to all
  df_psa_notrt     <- df_psa_notrt      # this is no trt/cohort parameters
  
  param_psa_total_temporary <- rbind(df_temporary, 
                                     df_psa_notrt, 
                                     df_temporary_all) # combine all the parameters
  l_m_Parameters[[n]] <- gen_psa(df_param_psa = param_psa_total_temporary) # make a list with the matrix of parameters for each iteration for the multiple drugs.
}

# Save the PA data
save(l_m_Parameters, file = "../output/l_m_Parameters.rda")  

# Check if there are different "treatment" groups
tail(param_psa_total_temporary$Treatment)
unique(param_psa_total_temporary$Treatment)

# Transform the data into DARTH style using the function gen_psa
m_Parameters <- df_param_psa <- gen_psa(df_param_psa = param_psa_total_temporary)
```

### 9.2.2 Create histograms of the PA parameters for a specific list
The selected list is split for treatment specific and parameters that are for all treatments 
```{r, eval = FALSE}
# This section can be used to investigate specific parameters of a specific treatment
# The next section however will be saved, which gives all parameters except an exclude list for all treatments

# Histogram of parameters for a treatment 
df_psa_input <- l_m_Parameters[[1]]

# Adjust the numbers of which parameters we would like to plot
length(colnames(df_psa_input))
head(df_psa_input)
 
df_psa_input_plot_hist_keyparam <- df_psa_input[, c(
  "p_IC", 
  "c_Trt_private",
  "c_Trt_public",
  "hr_D_Trt_timespan1", 
  "LOS_noTrt", 
  "LOS_Trt", 
  "n_age", 
  "c_Hospital", 
  "c_I_noVent", 
  "c_I_vent", 
  "c_Healthcare", 
  "c_recovery", 
  "p_H", 
  "p_IC_notrt", 
  "p_R_IC_D", 
  "p_R_H_D", 
  "p_R_IC_D_vent", 
  "p_R_IC_D_novent", 
  "p_vent", 
  "u_H", 
  "u_R_H", 
  "u_R_IC", 
  "c_RCT_fixed", 
  "c_RCT_ppo"
  )]
count(df_psa_input_plot_hist_keyparam)

#head(df_psa_input[, df_psa_input_plot_hist_keyparam])
  
plot <- ggplot(melt(df_psa_input_plot_hist_keyparam, variable.name = "Parameter"), aes(x = value)) +
       facet_wrap(~Parameter, scales = "free") +
       geom_histogram(aes(y = ..density..)) +
       theme_bw(base_size = 16) + 
       theme(axis.text = element_text(size = 8))
plot

# Extra code to store the PA histograms if of interest 
 ggsave(plot, path = here("../figures"), filename = paste("PSA_parameter_histogram", "_", n, ".png", sep =""))  # save the plot

 
 
 
 
 
```


### 9.2.3 Create histograms of the PA parameters for all treatments and all parameters, but remove irrelevant 

```{r, eval = TRUE}

# Select parameters of interest to plot
# NB: not all parameters are relevant, e.g. some do not have a distribution such as u_D = 0, however, not all parameters exist in each dataset
# Keep only parameters not in the "irrelevant" list below
v_psa_input_plot_hist_irrelevant <- c("n_days_timespan1", "rr_D_Trt_timespan2", "or_D_Trt_timespan2","hr_D_Trt_timespan2", "hr_D_Trt_timespan2_novent", "hr_D_Trt_timespan2_vent", "n_days_timespan2", "t_hr_D_Trt", "t_rr_D_Trt","t_or_D_Trt", "c_D", "u_D", "u_I", "e_H", "e_R_IC", "e_R_H", "e_D", "wtp", "t_Die_mj", "p_Die_1", "p_Die_2", "c_LY_2020", "c_RCT_pp_inc_fixed", "n_H_year", "n_H_day", "n_H_trial")

# This variables are the same for all treatments 

v_psa_input_plot_hist_cohort <- c("n_age", "c_Hospital", "c_I_noVent", "c_I_vent", "c_Healthcare", "c_recovery" ,
  "p_H", "p_IC_notrt", "p_R_IC_D", "p_R_H_D", "p_R_IC_D_vent", "p_R_IC_D_novent",
  "p_men", "p_vent", "u_H","u_R_H", "u_R_IC", "p_Private_insurance", "c_RCT_fixed", "c_RCT_ppo" )

v_psa_input_plot_hist_irrelevant_combined <- c(v_psa_input_plot_hist_irrelevant, v_psa_input_plot_hist_cohort)


# Create loop param histograms

for(n in names(l_param_trt)){ 

# Histogram of parameters for a treatment 
#df_psa_input <- l_m_Parameters[[1]] # 1 treatment, for coding
df_psa_input <- l_m_Parameters[[n]] # all treatments

# Remove irrelevant parameters
df_psa_input_plot_hist_keyparam <- df_psa_input[ , -which(names(df_psa_input) %in% v_psa_input_plot_hist_irrelevant_combined)]

m <- remove_date_from_name(n)

plot <- ggplot(melt(df_psa_input_plot_hist_keyparam, variable.name = "Parameter"), aes(x = value)) +
       facet_wrap(~Parameter, scales = "free") +
       geom_histogram(aes(y = ..density..                          )) +
       theme(axis.text = element_text(size = 6, vjust = 0.5, hjust = 1)) +
       theme(axis.text.x = element_text(angle = 60)) +                                                                # Change font size
       theme(strip.text.x = element_text(size = 4)) +
       ggtitle(paste("PA parameter distributions", m)) 
  
plot
# Extra code to store the PA histograms if of interest 
ggsave(plot, path = here("../figures"), filename = paste("PSA_parameter_histogram", "_", m, ".png", sep =""))


} # close loop



## Plot cohort only
# Remove irrelevant parameters
df_psa_input_plot_hist_keyparam_cohort <- df_psa_input[ , which(names(df_psa_input) %in% v_psa_input_plot_hist_cohort)]


plot <- ggplot(melt(df_psa_input_plot_hist_keyparam_cohort, variable.name = "Parameter"), aes(x = value)) +
       facet_wrap(~Parameter, scales = "free") +
       geom_histogram(aes(y = ..density..                          )) +
       theme(axis.text = element_text(size = 6, vjust = 0.5, hjust = 1)) +
       theme(axis.text.x = element_text(angle = 60)) +                                                                # Change font size
       theme(strip.text.x = element_text(size = 4)) +
       ggtitle(paste("PA parameter distributions")) 
  
plot
# Extra code to store the PA histograms if of interest 
ggsave(plot, path = here("../figures"), filename = paste("PSA_parameter_histogram_cohort.png", sep =""))







```












### 9.2.3 Initial data frames
```{r}
# Initialize dataframes with PA output 
# Dataframe of costs and effectiveness 
df_c_psa <- df_e_psa <- df_e_LY_psa <- as.data.frame(matrix(0, 
                                                            nrow = n_iter,
                                                            ncol = n_str))
colnames(df_c_psa) <- colnames(df_e_psa) <- colnames (df_e_LY_psa) <- v_names_str

# Matrix for the output of the PA 
v_output <- c("LY", "QALY", "Costs")            # Vector of output names
m_output <- matrix(NA, 
                   ncol = as.numeric(length(v_output)) * as.numeric(n_str), 
                   nrow = n_iter, 
                   dimnames = list(paste("Iteration", 1:n_iter, sep = " "), 
                                   (paste(rep(v_output, n_str), rep(c("notrt", "trt"), 
                                  each = length(v_output)), sep = " "))))

l_m_output <- list()

```

##9.2 Run PA 
```{r, eval = FALSE}

# select the treatment of interest
m_Parameters <- l_m_Parameters[[1]] 


# Run Markov model on each parameter set of PSA input dataset
for(n in names(l_param_trt)){  
  
  # select the treatment of interest
  m_Parameters <- l_m_Parameters[[n]] 
  
  for(g in 1:n_iter){
    l_param_psa <- as.list(m_Parameters[g, ]) # select the items for this iteration
    
    l_param_psa <- c(l_param_psa, l_input_general) # Combine with the general input
    l_param_psa$df_r_HD <- df_r_HD # Add the df with the mortality rate to the general input
    
    l_out_temp  <- calculate_cea_output_VOI_COVID(l_param_psa, n_wtp = l_param_psa$wtp, verbose = FALSE)
    
    # store key parameters
    df_c_psa[g, ]    <- l_out_temp$Cost
    df_e_psa[g, ]    <- l_out_temp$Effect
    df_e_LY_psa[g, ] <- l_out_temp$LY
  
    # Display simulation progress
    if(g/(n_iter/10) == round(g/(n_iter/10), 0)) { # display progress every 10%
      cat('\r', paste(g/n_iter * 100, "% PSA of treatment", n, "done & ", round(which(names(l_param_trt) == n)/length(names(l_param_trt)) * 100, 0), "% total PSA", sep = " "))
    
  }
    
    #Store the treatment specific values 
    m_output[, "Costs notrt"] <- df_c_psa$notrt
    m_output[, "Costs trt"]   <- df_c_psa$trt
  
    m_output[, "QALY notrt"]  <- df_e_psa$notrt
    m_output[, "QALY trt"]    <- df_e_psa$trt
  
    m_output[, "LY notrt"]    <- df_e_LY_psa$notrt
    m_output[, "LY trt"]      <- df_e_LY_psa$trt
    
    l_m_output[[n]] <- m_output

    }
  }


```

```{r}
save(l_m_output, file = "../output/l_m_output.rda")   # save the PSA data

```



### 9.2.1 Run PSA in parallel on MacOS
```{r}

# Inititate list
l_df_par <- l_m_output_par <-  list()

m_output_par <- matrix(NA, 
                   ncol = as.numeric(length(v_output)) * as.numeric(n_str), 
                   nrow = n_iter, 
                   dimnames = list(paste("Iteration", 1:n_iter, sep = " "), 
                                   (paste(rep(v_output, n_str), rep(c("notrt", "trt"), 
                                  each = length(v_output)), sep = " "))))

os <- get_os()
print(paste0("Parallelized PSA on ", os))
no_cores <- parallel::detectCores() - 2 # This line of code detects how many cores are available on a computer, and how many cores can be used to run the code. Running the code with more cores at the same time can help to decrease the running time. For example, if 4 cores are detected, the model will be run on 2 cores, while the user can (depending on their computer settings and options) continue to use their computer. This can also be adjusted to a cutom number of cores by uncommenting and adjusting the line below.
# no_cores <- 3
n_time_init_psa <- Sys.time()

# Run Markov model on each parameter set of PSA input dataset
for(n in names(l_param_trt)){  
  
  # select the treatment of interest
  m_Parameters <- l_m_Parameters[[n]] 

# ## Run parallelized PSA based on OS
 if(os == "macosx"){
   # Initialize cluster object
   cl <- parallel::makeForkCluster(no_cores)
   # Register clusters
   doParallel::registerDoParallel(cl)
   # Run parallelized PSA
   
   df_ce <- foreach::foreach(g = 1:n_iter, .combine = rbind) %dopar% {
     
     l_param_psa <- as.list(m_Parameters[g, ])
     l_param_psa <- c(l_param_psa, l_input_general) # Combine with the general input
     l_param_psa$df_r_HD <- df_r_HD                 # Add the df with the mortality rate to the general input
   
     
     l_out_temp <- calculate_cea_output_VOI_COVID(l_param_psa, n_wtp = l_param_psa$wtp, verbose = FALSE)
     df_ce <- c(l_out_temp$Cost, 
                l_out_temp$Effect, 
                l_out_temp$LY,
                l_out_temp$NMB,
                l_out_temp$NHB)
    
   }

    # Save the output
     m_output_par[, "Costs notrt"]   <- df_ce[, 1]
     m_output_par[, "Costs trt"]     <- df_ce[, 2]
     
     m_output_par[, "QALY notrt"] <- df_ce[, 3]
     m_output_par[, "QALY trt"]   <- df_ce[, 4]
     
     m_output_par[, "LY notrt"]   <- df_ce[, 5]
     m_output_par[, "LY trt"]     <- df_ce[, 6]
  
   }
 l_df_par[[n]] <- df_ce
 l_m_output_par[[n]] <- m_output_par
 
  }

n_time_end_psa <- Sys.time()
stopCluster(cl)

n_time_init_psa 
n_time_end_psa - n_time_init_psa 

```

## 9.2.2 Save and load PA files
```{r}
save(l_m_output_par, file = "../output/l_m_output_par.rda")    #  save the parallel data from the PSA

save(l_df_par, file = "../output/l_df_par.rda")    #  save the parallel data from the PSA
```


```{r, eval = FALSE}
# Test if parallel gives the same results

l_check_par <- list()
for (n in names(l_param_trt) ){

l_m_output_par[[n]] == l_m_output[[n]]

l_check_par[[n]] <- summary(l_m_output_par[[n]] == l_m_output[[n]])

}
# Check if we get identical results
l_check_par
```


```{r}
for(n in names(l_param_trt)){
  
    # store key parameters
    df_c_psa[, 1:2]    <- l_df_par[[n]][, 1:2]
    df_e_psa[, 1:2]    <- l_df_par[[n]][, 3:4]
    df_e_LY_psa[, 1:2] <- l_df_par[[n]][, 5:6]

    
    #Store the treatment specific values 
    m_output_par[, "Costs notrt"] <- df_c_psa$notrt
    m_output_par[, "Costs trt"]   <- df_c_psa$trt
  
    m_output_par[, "QALY notrt"]  <- df_e_psa$notrt
    m_output_par[, "QALY trt"]    <- df_e_psa$trt
  
    m_output_par[, "LY notrt"]    <- df_e_LY_psa$notrt
    m_output_par[, "LY trt"]      <- df_e_LY_psa$trt
    
    l_m_output[[n]] <- m_output_par
}



save(l_m_output, file = "../output/l_m_output.rda") 
```


```{r, eval = FALSE}
load(file = "../output/l_m_output.rda")
# NB: this chunk is set to eval = FALSE, however, when not wanting to run the entire PA but simply load the previously generated PA output set, run this line
```

## 9.3 Matrices for PA run and final output
```{r, eval = TRUE}
# Matrix for the output of the PSA 
v_Output <- c("LY", "QALY", "Costs")            # Vector of output names
m_output <- matrix(NA, 
                   ncol = as.numeric(length(v_Output)) * as.numeric(n_str), 
                   nrow = n_iter, 
                   dimnames = list(paste("Iteration", 1:n_iter, sep = " "), 
                                   (paste(rep(v_Output, n_str), rep(1:n_str, 
                                  each = length(v_Output)), sep = " "))))



# Fills in transition matrix for each iteration with values from the distribution matrices
m_P_notrt_PSA <- m_P_trt_PSA <- m_R_costs_notrt_PSA <- m_R_costs_trt_PSA <- matrix(NA, nrow = n_states, ncol = n_states, 
                                      dimnames = list(v_names_states, v_names_states))
  
m_M_notrt_PSA <- m_M_trt_PSA <- matrix(NA, 
                                nrow     = n_t + 1, ncol = n_states,
                                dimnames = list(paste("cycle", 0:n_t, sep = " "), v_names_states))
 

# initialize multidimensional array for both strategies
a_A_notrt_PSA <- a_A_trt_PSA <- a_Y_costs_notrt_PSA <- a_Y_costs_trt_PSA <- array(0, 
                              dim = c(n_states, n_states, n_t + 1), 
                              dimnames = list(v_names_states, v_names_states, 0:n_t)) 
```


## 9.4 Incremental effects
```{r}

# Create lists
l_df_PSA_QALY               <- l_df_PSA_LY <- l_df_PSA_Costs <- list()
l_df_cea_PSA_LY             <- l_df_cea_PSA_QALY             <- list()

l_v_IncrLY_PSA   <- l_v_IncrQALY_PSA <- l_v_IncrCosts_PSA <- list()
l_df_output_incr <- list()

for(n in names(l_param_trt)){  
  m_output  <- l_m_output[[n]] # Select on output frame
  df_output <- as.data.frame(l_m_output[[n]])

  # Incremental effects between intervention and control in lifeyears 
  # 1 = no Treatment 
  # 2 = Treatment
 l_v_IncrLY_PSA[[n]]    <- m_output[, "LY trt"]    - m_output[, "LY notrt"] 
 l_v_IncrQALY_PSA[[n]]  <- m_output[, "QALY trt"]  - m_output[, "QALY notrt"] 
 l_v_IncrCosts_PSA[[n]] <- m_output[, "Costs trt"] - m_output[, "Costs notrt"]

 
 df_output$iLY    <- m_output[, "LY trt"]    - m_output[, "LY notrt"] 
 df_output$iQALY  <- m_output[, "QALY trt"]  - m_output[, "QALY notrt"] 
 df_output$iCosts <- m_output[, "Costs trt"] - m_output[, "Costs notrt"]
 
 
l_df_PSA_LY[[n]] <- df_PSA_LY<- data.frame(Strategy = v_names_str,
                     Cost = c(mean(m_output[, "Costs notrt"]), mean(m_output[, "Costs trt"])),
                     LY = c(mean(m_output[, "LY notrt"]), mean(m_output[, "LY trt"])),
                     Inc_Cost =   c(NA, mean(l_v_IncrCosts_PSA[[n]])),
                     Inc_Effect = c(NA, mean(l_v_IncrLY_PSA[[n]])))
                     

l_df_cea_PSA_LY[[n]] <- calculate_icers(cost   = df_PSA_LY$Cost,
                                      effect   = df_PSA_LY$LY,
                                    strategies = df_PSA_LY$Strategy)



l_df_PSA_QALY[[n]] <- df_PSA_QALY <- data.frame(Strategy = v_names_str,
                     Cost = c(mean(m_output[, "Costs notrt"]), mean(m_output[, "Costs trt"])),
                     QALY = c(mean(m_output[, "QALY notrt"]),  mean(m_output[, "QALY trt"])),
                     Inc_Cost = c(NA, mean(l_v_IncrCosts_PSA[[n]])),
                     Inc_Effect = c(NA, mean(l_v_IncrQALY_PSA[[n]])))
                     
l_df_cea_PSA_QALY[[n]] <- calculate_icers(cost   = df_PSA_QALY$Cost,
                                        effect   = df_PSA_QALY$QALY,
                                      strategies = df_PSA_LY$Strategy)


l_df_output_incr[[n]] <- df_output

### QALY ####
# Calculate net monetary benefit
   NMB  <- (df_PSA_QALY$QALY * l_param_trt[[n]]$wtp) - df_PSA_QALY$Cost
   iNMB <-  mean(df_output$iQALY) * l_param_trt[[n]]$wtp  - mean(df_output$iCosts)
   l_df_PSA_QALY[[n]]$NMB <- NMB
   l_df_PSA_QALY[[n]]$iNMB[l_df_PSA_QALY[[n]]$Strategy == "trt"] <- iNMB


 # Calculate Net Health benefit 
   NHB <-  df_PSA_QALY$QALY - (df_PSA_QALY$Cost / l_param_trt[[n]]$wtp)
   l_df_PSA_QALY[[n]]$NHB <- NHB
   l_df_output_incr[[n]]$"NHB QALY" <- NHB
   
   iNHB <-   mean(df_output$iQALY) - (mean(df_output$iCosts) / l_param_trt[[n]]$wtp  )
    
   l_df_PSA_QALY[[n]]$iNHB[l_df_PSA_QALY[[n]]$Strategy == "trt"] <- iNHB
   
   
   
   ### LY ####
# Calculate net monetary benefit
   l_df_PSA_LY[[n]]$NMB <- (df_PSA_LY$LY * l_param_trt[[n]]$wtp) - df_PSA_LY$Cost
    
    iNMB <-  mean(df_output$iLY) * l_param_trt[[n]]$wtp  - mean(df_output$iCosts)
    l_df_PSA_LY[[n]]$iNMB[l_df_PSA_LY[[n]]$Strategy == "trt"] <- iNMB

 # Calculate Net Health benefit
   l_df_PSA_LY[[n]]$NHB <- df_PSA_LY$LY - (df_PSA_LY$Cost / l_param_trt[[n]]$wtp)
   
   iNHB <-   mean(df_output$iLY) - (mean(df_output$iCosts) / l_param_trt[[n]]$wtp  )
   l_df_PSA_LY[[n]]$iNHB[l_df_PSA_LY[[n]]$Strategy == "trt"] <- iNHB
   

   
   
}


save(l_df_PSA_QALY,     file = "../output/l_df_PSA_QALY.rda")
save(l_df_cea_PSA_QALY, file = "../output/l_df_cea_PSA_QALY.rda")
save(l_df_cea_PSA_LY,   file = "../output/l_df_cea_PSA_LY.rda")
save(l_df_output_incr,  file = "../output/l_df_output_incr.rda")
```



## 9.5 CE plane
```{r}
# create a list with uncertainty for presenting the 95% lower and upper bound
# This is used for reporting in the manuscript
l_df_cea_PSA_LY_uncertainty <- l_df_cea_PSA_QALY_uncertainty <- list()

for (n in names(l_param_trt)){
# Create PSA object for `dampack`
## Life Years ##
l_psa_plot_LY <- make_psa_obj(cost  = as.data.frame(l_m_output[[n]][, c("Costs notrt", "Costs trt")]), 
                      effectiveness = as.data.frame(l_m_output[[n]][, c("LY notrt", "LY trt")]), 
                      parameters    = l_m_Parameters[[n]], 
                      strategies    = v_names_str)

l_df_cea_PSA_LY_uncertainty[[n]] <- calculate_icers_psa(l_psa_plot_LY, uncertainty = TRUE)

plot(l_psa_plot_LY) + 
        geom_vline(xintercept = 0, color = my_darkgray, size = 0.6) +
  geom_hline(yintercept = 0, color = my_darkgray, size = 0.6) +
  labs(title = paste("Cost-effectiveness plane", n, sep = " "), 
       subtitle = "Effectiveness are life years (LY)") +
  scale_color_manual(values = c(my_lightred, my_green, my_black)) + 
  scale_fill_manual( values = c(my_lightred, my_green, my_black))


ggsave(path = here("../figures"), filename = paste("CE-plane_LY", "_", remove_date_from_name(n), ".png", sep =""))  # save the plot


## QALY ##

l_psa_plot_QALY <- make_psa_obj(cost  = as.data.frame(l_m_output[[n]][, c("Costs notrt", "Costs trt")]), 
                      effectiveness = as.data.frame(l_m_output[[n]][, c("QALY notrt", "QALY trt")]), 
                      parameters    = l_m_Parameters[[n]], 
                      strategies    = v_names_str)

  plot(l_psa_plot_QALY) + 
    labs(title = paste("Cost-effectiveness plane", remove_date_from_name(n), sep=" "), subtitle = "Effectiveness are QALYs") +
    geom_vline(xintercept = 0, color = my_darkgray, size = 0.6) +
    geom_hline(yintercept = 0, color = my_darkgray, size = 0.6) +
    scale_color_manual(values = c(my_red, my_darkgreen, my_black)) + 
    scale_fill_manual(values = c(my_red, my_darkgreen, my_black))

  l_df_cea_PSA_QALY_uncertainty[[n]] <- calculate_icers_psa(l_psa_plot_QALY, uncertainty = TRUE)

ggsave(path = here("../figures"), filename = paste("CE-plane_QALY", "_", remove_date_from_name(n), ".png", sep =""))  # save the plot

}
```


### 9.5.1 CE-plane Incremental 
```{r}

for (n in names(l_param_trt)){
  
  plot_inc_CE_plane_LY <- make_psa_obj(cost  = as.data.frame(l_df_output_incr[[n]]$iCosts), 
                               effectiveness = as.data.frame(l_df_output_incr[[n]]$iLY), 
                                parameters   = l_m_Parameters[[n]], 
                               strategies    = "Incremental")
  
  plot(plot_inc_CE_plane_LY) + 
      geom_vline(xintercept = 0, color = my_darkgray, size = 0.6) +
      geom_hline(yintercept = 0, color = my_darkgray, size = 0.6) +
    labs(title     = paste("Incremental Cost-effectiveness plane"), 
        subtitle   = paste(n, ": intervention vs control", sep = " ")) + 
          xlab("Incremental Effectiveness (LY)") +
      ylab("Incremental Costs (USD)") +
    scale_color_manual(values = c(my_darkgray, my_black)) + 
    scale_fill_manual(values = c(my_darkgray, my_black))
  
  ggsave(path = here("../figures"), 
         filename = paste("CE-plane_incr_LY", "_", remove_date_from_name(n), ".png", sep = ""))  # save the plot


    plot_inc_CE_plane_QALY <- make_psa_obj(cost  = as.data.frame(l_df_output_incr[[n]]$iCosts), 
                               effectiveness = as.data.frame(l_df_output_incr[[n]]$iQALY), 
                                parameters   = l_m_Parameters[[n]], 
                               strategies    = "Incremental")
  
  plot(plot_inc_CE_plane_QALY) + 
    labs(title     = paste("Incremental Cost-effectiveness plane"), 
         subtitle =   paste(n, ": intervention vs control", sep = " ")) +
      xlab("Incremental Effectiveness (QALY)") +
      ylab("Incremental Costs (USD)") +  
    geom_vline(xintercept = 0, color = my_darkgray, size = 0.6) +
  geom_hline(yintercept = 0, color = my_darkgray, size = 0.6) +
        scale_color_manual(values = c(my_yellow, my_black)) + 
    scale_fill_manual(values = c(my_yellow, my_black))
  
  ggsave(path = here("../figures"), 
         filename = paste("CE-plane_incr_QALY", "_", remove_date_from_name(n), ".png", sep = ""))  # save the plot

}

```


### 9.5.2 Incremental CE-plane - all treatments

```{r}
load(file = "../output/l_df_output_incr.rda")
#load(file = "../output/l_param_trt.rda")
load(file = "../output/l_param_trt_basecase.rda")

m_CE_summary <- matrix(NA, nrow = 2, ncol = length(names(l_param_trt)))
colnames(m_CE_summary) <- names(l_param_trt)
rownames(m_CE_summary) <- c("iCosts", "iEffects")


# Add WTP threshold to plot
# NB: it is possible too add other WTP ratio's by adjusting the slope number
# https://stackoverflow.com/questions/49418545/what-is-the-best-way-to-add-ratio-lines-to-plot-in-ggplot2
ratios <- data.frame(intercept = 0, 
                     slope = c(100000),  # Adjust slope for different WTP
                     Ratio = paste("WTP"))


for (n in names(l_param_trt)){
  m_CE_summary["iCosts", n]   <- mean(l_df_output_incr[[n]]$iCosts)
  m_CE_summary["iEffects", n] <- mean(l_df_output_incr[[n]]$iQALY)
}


    df_m_CE_summary <- as.data.frame(m_CE_summary)
    plot_inc_CE_summary <- make_psa_obj(cost  = df_m_CE_summary["iCosts", ] , 
                               effectiveness  = df_m_CE_summary["iEffects", ], 
                                parameters    = df_m_CE_summary["iCosts", ], 
                                strategies    = colnames(df_m_CE_summary))
    
  plot(plot_inc_CE_summary) + 
    labs(title     = paste("Incremental Cost-effectiveness plane"), 
         subtitle =   paste("Mean estimates of intervention vs control PA ")) +
      xlab("Incremental Effectiveness (QALY)") +
      ylab("Incremental Costs (USD)") +  
    geom_vline(xintercept = 0, color = my_darkgray, size = 0.6) +
  geom_hline(yintercept = 0, color = my_darkgray, size = 0.6) +
    geom_abline(aes(intercept = 0, slope = 100000),
              show.legend = FALSE, size = 1,colour = my_lightred) 

  
  ggsave(path = here("../figures"), 
         filename = paste("CE-plot_inc_CE_summary.png"))  # save the plot

  
  # Select those we want to report 
  m_CE_summary_report <- m_CE_summary[, l_names$v_names_trt_report]
  colnames(m_CE_summary_report) <- l_names$v_names_trt_report_full
  
  df_m_CE_summary_report <- as.data.frame(m_CE_summary_report)
  
      plot_inc_CE_summary_report <- make_psa_obj(cost  = df_m_CE_summary_report["iCosts", ] , 
                               effectiveness  = df_m_CE_summary_report["iEffects", ], 
                                parameters    = df_m_CE_summary_report["iCosts", ], 
                                strategies    = colnames(df_m_CE_summary_report))
  
          # Give lables full names
    plot_inc_CE_summary_report$strategies <- l_names$v_names_trt_report_full
   colnames(plot_inc_CE_summary_report$effectiveness) <- l_names$v_names_trt_report_full
   colnames(plot_inc_CE_summary_report$cost) <- l_names$v_names_trt_report_full
      
    plot(plot_inc_CE_summary_report) + 
    labs(title     = paste("Incremental Cost-effectiveness plane"), 
         subtitle =   paste("Mean estimates of intervention vs control PA")) +
      xlab("Incremental Effectiveness (QALY)") +
      ylab("Incremental Costs (USD)") +  
    geom_vline(xintercept = 0, color = my_darkgray, size = 0.6) +
    geom_hline(yintercept = 0, color = my_darkgray, size = 0.6) +
    scale_color_manual(values = rep(c(my_yellow, my_darkgray, my_lightgray,  my_lightgreen, my_darkgreen, my_red, my_darkred, my_lightred),2),
                       name = "Strategy") + 
    scale_fill_manual(values = rep(c(my_yellow, my_darkgray, 
                                     my_lightgray,my_lightgreen, 
                                     my_darkgreen, my_red, 
                                     my_darkred, my_lightred),2),
                      labels = l_names$v_names_trt_report_full,
                      name = "Strategy") + 
      geom_abline(aes(intercept = 0, slope = 100000),
              show.legend = FALSE, size = 1, colour = my_lightred)+
    annotate(geom="text", x=0.30, y=20000, label="WTP",
              color=my_lightred)
    
  
    ggsave(path = here("../figures"), 
         filename = paste("CE-plot_inc_CE_summary_report.png"))  # save the plot

```




### 9.5.3 Incremental CE-plane - all treatments with uncertainty elliplse

```{r}
load(file = "../output/l_df_output_incr.rda")

df_test         <- do.call(cbind.data.frame, l_df_output_incr)
df_test_iQALY   <- df_test[str_detect(colnames(df_test), c("iQALY"))]
colnames(df_test_iQALY) <-  gsub(".iQALY", "", colnames(df_test_iQALY))
df_test_iCosts  <- df_test[str_detect(colnames(df_test), c("iCosts"))]
colnames(df_test_iCosts) <-  gsub(".iCosts", "", colnames(df_test_iCosts))

# make psa object  
plot_inc_CE_summary <- make_psa_obj(cost  = df_test_iQALY, 
                               effectiveness  = df_test_iCosts, 
                                parameters    = df_test_iCosts, 
                                strategies    = colnames(df_test_iCosts))
  # plot psa object  
  plot(plot_inc_CE_summary, ellipse = TRUE, alpha = 0) + 
    labs(title     = paste("Incremental Cost-effectiveness plane"), 
         subtitle =   paste("Mean estimates of intervention vs control PA")) +
      xlab("Incremental Effectiveness (QALY)") +
      ylab("Incremental Costs (USD)") +  
    geom_vline(xintercept = 0, color = "darkgray", size = 0.6) +
  geom_hline(yintercept = 0, color = "darkgray", size = 0.6)
  
  ggsave(path = here("../figures"), 
         filename = paste("CE-plot_inc_CE_summary_ellipse.png"))  # save the plot

  
  # Select those we like to report 
df_test_iQALY_report  <- df_test_iQALY[, colnames(df_test_iQALY) %in% l_names$v_names_trt_report] 
df_test_iCosts_report <- df_test_iCosts[, colnames(df_test_iQALY) %in% l_names$v_names_trt_report] 
  

      plot_inc_CE_summary_report <- make_psa_obj(cost  = df_test_iCosts_report , 
                               effectiveness  = df_test_iQALY_report, 
                                parameters    = df_test_iCosts_report, 
                                strategies    = l_names$v_names_trt_report_full)
  
                # Give 
    plot_inc_CE_summary_report$strategies <- l_names$v_names_trt_report_full
   colnames(plot_inc_CE_summary_report$effectiveness)<- l_names$v_names_trt_report_full
   colnames(plot_inc_CE_summary_report$cost) <- l_names$v_names_trt_report_full
      
   v_colors_plot <- v_my_color[1:length(colnames(plot_inc_CE_summary_report$cost))]   
   
      
    plot(plot_inc_CE_summary_report, ellipse = TRUE, alpha = 0) + 
    labs(title     = paste("Incremental Cost-effectiveness plane"), 
         subtitle =   paste("Mean estimates of intervention vs control PA")) +
      xlab("Incremental Effectiveness (QALY)") +
      ylab("Incremental Costs (USD)") +  
    geom_vline(xintercept = 0, color = my_darkgray, size = 0.6) +
    geom_hline(yintercept = 0, color = my_darkgray, size = 0.6) +
      xlim(c(-1, 1.5)) +
      ylim(c(-50000, 50000)) +
      scale_color_manual(values = v_my_color_main) + 
    scale_fill_manual(values = v_my_color_main)
  
  
    ggsave(path = here("../figures"), 
         filename = paste("CE-plot_inc_CE_summary_report_ellipse.png"))  # save the plot

```



### 9.5.4 CE-plane Incr LY and QALY
```{r}

for (n in v_names_trt){
  
  plot_incr_both <- make_psa_obj(cost  = as.data.frame(l_df_output_incr[[n]][, c("iCosts", "iCosts")]), 
                         effectiveness = as.data.frame(l_df_output_incr[[n]][, c("iLY", "iQALY")]), 
                         parameters    = l_m_Parameters[[n]], 
                         strategies    = c("LY", "QALY"))


  plot(plot_incr_both) + 
    labs(title = paste("Incremental Cost-Effectiveness plane"),
         subtitle =   paste(n, ": intervention vs control", sep = " ")) +
    xlab("Incremental Effectiveness") +
    ylab("Incremental Costs (USD)") +
    geom_vline(xintercept = 0, color = my_darkgray, size = 0.6) +
    geom_hline(yintercept = 0, color = my_darkgray, size = 0.6) +
    scale_color_manual(values = c(my_darkgray, my_yellow,  my_black)) +  
    scale_fill_manual(values  = c(my_darkgray, my_yellow,  my_black)) + 
    theme(legend.title = element_blank())
  
   ggsave(path = here("../figures"), 
         filename = paste("CE-plane_incr_combined", "_", remove_date_from_name(n), ".png", sep = ""))  # save the plot

}

```

```{r, echo = FALSE, out.width="30%", }
# These functions produce a character vector of the names of files or directories in the named directory. With a pattern similar to what you specify in pattern
myimages <- list.files("../figures/", pattern = "CE-plane_incr_QALY", full.names = FALSE)


```

# 9.6 VOI
```{r}
### 2020/08/31 ###
# VOI analysis
# Based on:
# Jalal H, Alarid-Escudero F. A Gaussian Approximation Approach for Value of Information Analysis. Med. Decis. Making. 2017:116

# make a list with the population size

l_pop <- l_pop_trial <-  l_pop_all <- list()

for (n in names(l_param_trt)){
 if(l_param_trt[[n]]$p_IC == 1){
   # if this drug is only given to IC patients, we should only consider the IC patients in the calculation of patients that can benefit. We therefore, multiply the total population with the probability of being admitted to the IC
   
    pop       <- l_param_trt[[n]]$n_H_year * l_param_trt[[n]]$p_IC_notrt
    pop_trial <- l_param_trt[[n]]$n_H_trial * l_param_trt[[n]]$p_IC_notrt
   # In this case the population is slightly different as this drug is only given the IC patients
    l_pop[[n]] <- pop  # The total population in a year 
    l_pop_trial[[n]] <- pop_trial
    
    l_pop_all[[n]]$n_patients_current <- pop_trial
    l_pop_all[[n]]$n_patients_future  <- pop
    } else{
 pop       <- l_param_trt[[n]]$n_H_year 
 pop_trial <- l_param_trt[[n]]$n_H_trial 
 
 l_pop[[n]] <- pop # The total population in a year  
 l_pop_trial[[n]] <- pop_trial
     l_pop_all[[n]]$n_patients_current <- pop_trial
    l_pop_all[[n]]$n_patients_future  <- pop
}
}

save(l_pop, file = "../output/l_pop.rda")

```

### 9.6.1 Specify costs and effects
```{r}

l_res <- list()
for (n in v_names_trt){
  m_output <- l_m_output[[n]]
  ly_s1     <- as.vector(m_output[, "LY notrt"]) # Select the LY for the first strategy
  ly_s2     <- as.vector(m_output[, "LY trt"]) # Select the LY for the first strategy

  qaly_s1   <- as.vector(m_output[, "QALY notrt"]) # Select the QALYs for the first   strategy
  qaly_s2   <- as.vector(m_output[, "QALY trt"]) # Select the QALYs for the first   strategy

  cost_s1   <- as.vector(m_output[, "Costs notrt"])
  cost_s2   <- as.vector(m_output[, "Costs trt"])

# results of the analysis 
  res_ly   <- data.frame(as.vector(m_output[, "LY notrt"]), 
                         as.vector(m_output[, "LY trt"]))
  colnames(res_ly) <- c("LY notrt", "LY trt")
  l_res[[n]]$res_ly <- res_ly

  res_qaly <- data.frame(as.vector(m_output[, "QALY notrt"]), 
                         as.vector(m_output[, "QALY trt"]))
  colnames(res_qaly) <- c("QALY notrt", "QALY trt")
  l_res[[n]]$res_qaly<- res_qaly

  res_cost <- data.frame(as.vector(m_output[, "Costs notrt"]), 
                         as.vector(m_output[, "Costs trt"]))
  colnames(res_cost) <- c("Costs notrt", "Costs trt")
  l_res[[n]]$res_cost<- res_cost
}

```

### 9.6.2 CEACs and CEAF
```{r}
########################################################################################################
## CEACs and CEAF and EVPI
########################################################################################################
v_wtp <- seq(0, 200000, by = 10000)

l_out_ceaf_LY <- l_out_ceaf_QALY <- list() #initiate lists

for (n in v_names_trt){
  
# Cost effectiveness acceptability curve for Life Years
l_out_ceaf_LY[[n]] <- ceaf_changed(v.wtp      = v_wtp, 
                                   strategies = v_names_str, 
                                   m.e        = l_res[[n]]$res_ly, 
                                   m.c        = l_res[[n]]$res_cost, 
                                   effectunit = "LY",  
                                   ceaf.out   = TRUE )
ggsave(path = here("../figures"), filename = paste("CEAF_LY", "_", remove_date_from_name(n), ".png", sep = ""))

# Cost effectiveness acceptability curve for QALY
l_out_ceaf_QALY[[n]] <- ceaf_changed(v.wtp      = v_wtp, 
                                     strategies = v_names_str, 
                                     m.e        = l_res[[n]]$res_qaly, 
                                     m.c        = l_res[[n]]$res_cost, 
                                     effectunit = "QALY", 
                                     ceaf.out   = TRUE) 

ggsave(path = here("../figures"), filename = paste("CEAF_QALY", "_", remove_date_from_name(n), ".png", sep = ""))

ggarrange(l_out_ceaf_LY[[n]]$gg.ceaf, l_out_ceaf_QALY[[n]]$gg.ceaf, 
          ncol = 1, nrow = 2,
          legend = "bottom",
          common.legend = TRUE)

ggsave(path = here("../figures"), filename = paste("CEAF_combined", "_", remove_date_from_name(n), ".png", sep = ""))


}

#save the output 
# This can be used in the markdown to make the figures
save(l_out_ceaf_LY, file = "../output/l_out_ceaf_LY.RData")
save(l_out_ceaf_QALY, file = "../output/l_out_ceaf_QALY.RData" )

```

### 9.6.3.1 Calculate EVPI
```{r}
l_out_evpi <- l_out_evpi_LY <- l_out_evpi_QALY <- l_evpi_value <- list()
for (n in names(l_param_trt)){
  
# pop = 1 for EVPI per person & pop = pop for population EVPI  
  
  # calculate population EVPI for LY
l_out_evpi_LY[[n]] <- l_out_evpi[[n]]  <- evpi(v.wtp = v_wtp,
                                          m.e   = l_m_output[[n]][, c("LY notrt", "LY trt")], 
                                          m.c   = l_m_output[[n]][, c("Costs notrt", "Costs trt")], 
                                          pop   = l_pop[[n]]) 

  # calculate population EVPI for QALY
l_out_evpi_QALY[[n]]  <- evpi(v.wtp = v_wtp,
                              m.e   = l_m_output[[n]][, c("QALY notrt", "QALY trt")], 
                              m.c   = l_m_output[[n]][, c("Costs notrt", "Costs trt")], 
                              pop   = l_pop[[n]]) 


l_out_evpi[[n]]$EVPI[l_out_evpi[[n]]$WTP == 100000] # print LY result for a specific WTP
l_out_evpi_QALY[[n]]$EVPI[l_out_evpi_QALY[[n]]$WTP == 100000] # print QALY result for a specific WTP

# store in a list
l_evpi_value[[n]] <- cbind(WTP       = l_out_evpi[[n]]$WTP, 
                           EVPI_LY   = l_out_evpi_LY[[n]]$EVPI, 
                           EVPI_QALY = l_out_evpi_QALY[[n]]$EVPI) 
}

# export the EVPI data 
save(l_evpi_value, file = "../output/l_evpi_value.rda")  
save(l_res,        file = "../output/l_res.rda")
save(l_param_trt,  file = "../output/l_param_trt.rda")

```


### 9.6.3.1.1 Plot EVPI
```{r}

l_evpi_obj_QALY <- list()
l_evpi_obj_LY <- list()

for(n in names(l_param_trt)){
  
  evpi_obj <- l_evpi_value[[n]][, c(1, 3)]
  evpi_obj <- as.data.frame(evpi_obj)
  
  l_evpi_obj_QALY[[n]] <- evpi_obj
  
  # 1. Open pgn file
  png(paste("../figures/EVPI_QALY", "_", remove_date_from_name(n), ".png", sep =""))

  # 2. Create the plot
  p <- plot(evpi_obj,
            type = "l",
          txtsize = 16, 
          effect_units = "QALY", 
          currency = "Dollars ($)",
          xbreaks = seq(0, 200, by = 10), 
          ylim = c(0, max(evpi_obj))) 
    
  p
  
    # 3. Close the file
    dev.off()
    
           save(p, file = paste("../output/plot_EVPI_QALY", "_", remove_date_from_name(n), ".RData", sep =""))
    
  evpi_obj <- l_evpi_value[[n]][, c(1, 2)]
  evpi_obj <- as.data.frame(evpi_obj)
  l_evpi_obj_LY[[n]] <- evpi_obj
  
  # 1. Open pgn file
  png(paste("../figures/EVPI_LY", "_", remove_date_from_name(n), ".png", sep =""))

  # 2. Create the plot
  p <- plot(evpi_obj,
            type = "l",
          txtsize = 16, 
          effect_units = "LY", 
          currency = "Dollars ($)",
          xbreaks = seq(0, 200, by = 10), 
          ylim = c(0, max(evpi_obj))) 
    
  
  p
  
    # 3. Close the file
    dev.off()
    
            
       
}

save(l_evpi_obj_LY, file = "../output/l_evpi_obj_LY.RData")

save(l_evpi_obj_QALY, file = "../output/l_evpi_obj_QALY.RData")

```

### 9.6.3.2 Calculate EVPPI
```{r}
# In our study, we consider whether or not a new RCT should be considered. This new RCT would only investigate the treatment effect parameter, therefore, we only investigate the EVPPI for the parameters related to the treatment effect. In VOI addressing other questions, it is also possible to select a subset of parameters and investigate the value of gathering more information on that set of parameters.

l_df_evppi <- l_df_evppi_pop <- l_df_param_nmb_LY <- l_df_param_nmb_QALY  <- l_m_param <- list()
v_evppi_LY <-  v_evppi_QALY <- length(v_wtp)


for (n in names(l_param_trt)){
         l_df_evppi[[n]]     <- as.data.frame(array(0, dim = c(length(v_wtp), 2)))
colnames(l_df_evppi[[n]])    <- c("WTP", "EVPPI")
         l_df_evppi[[n]]$WTP <- v_wtp

  m_Parameters <- l_m_Parameters[[n]]

# Code to select parameters of interest for EVPPI
  v_names_param <- names(m_Parameters)
  
  v_trt_type_name <- c("rr_D_Trt_timespan1", 
                       "rd_D_Trt_timespan1", 
                       "or_D_Trt_timespan1", 
                       "hr_D_Trt_timespan1")
  v_trt_type <- c("RR",
                  "RD",
                  "OR",
                  "HR")
  # Make a dateframe
  m_trt_type <- as.data.frame(cbind(v_trt_type_name, v_trt_type))
  # select the full name of the treatment type
  name <- v_names_param[ which(v_names_param %in% v_trt_type_name)]
  # match it with the corresponding treatment type
  trt_effect <- m_trt_type$v_trt_type[m_trt_type$v_trt_type_name == name] #
  
    vent <- FALSE  # make a variable that by default is FALSE
  if(trt_effect == "RR" & !is.null(m_Parameters$rr_D_Trt_timespan1_vent)){
    vent <- TRUE # if  we have information about ventilation, overwrite
  }
  if(trt_effect == "RD" & !is.null(m_Parameters$rd_D_Trt_timespan1_vent)){
    vent <- TRUE
  }
  if(trt_effect == "OR" & !is.null(m_Parameters$or_D_Trt_timespan1_vent)){
    vent <- TRUE
  }
  if(trt_effect == "HR" & !is.null(m_Parameters$hr_D_Trt_timespan1_vent)){
    vent <- TRUE
  }
  
  
    if(vent == FALSE){
      if (trt_effect == "RR"){
          l_m_param[[n]] <- m_param <- m_Parameters[, c("rr_D_Trt_timespan1")] 
      }
        if (trt_effect == "RD"){
          l_m_param[[n]] <- m_param <- m_Parameters[, c("rd_D_Trt_timespan1")] 
        }
           if (trt_effect == "OR"){
          l_m_param[[n]] <- m_param <- m_Parameters[, c("or_D_Trt_timespan1")] 
           }
         if (trt_effect == "HR"){
          l_m_param[[n]] <- m_param <- m_Parameters[, c("hr_D_Trt_timespan1")] 
      }
    } else if (vent == TRUE){
            if (trt_effect == "RR"){
          l_m_param[[n]] <- m_param <- m_Parameters[, c("rr_D_Trt_timespan1_vent",
                                                        "rr_D_Trt_timespan1_novent")] 
      }
        if (trt_effect == "RD"){
          l_m_param[[n]] <- m_param <- m_Parameters[, c("rd_D_Trt_timespan1_vent",
                                                        "rd_D_Trt_timespan1_novent")] 
        }
           if (trt_effect == "OR"){
          l_m_param[[n]] <- m_param <- m_Parameters[, c("or_D_Trt_timespan1_vent",
                                                        "or_D_Trt_timespan1_novent")] 
           }
         if (trt_effect == "HR"){
          l_m_param[[n]] <- m_param <- m_Parameters[, c("hr_D_Trt_timespan1_vent",
                                                        "hr_D_Trt_timespan1_novent")] 
      }
    }

  }# close the loop for treatment


for (n in names(l_param_trt)){
# Function - run the function to calculate EVVPI for different v_wtp
for(i in 1:length(v_wtp)){  
  
  ## Create a new data frame for the chosen WTP ##
  WTP <- v_wtp[i]
  m_nmb_LY <- NMB_function(wtp    = WTP,
                        effect = l_res[[n]]$res_ly, 
                        costs  = l_res[[n]]$res_cost) #for NMB
  #m.nmb <- NMB_function2(wtp=WTP,effect=res.ly, costs=res.cost) #for NHB (here WTP cannot be 0)
  l_df_param_nmb_LY[[n]] <- data.frame(l_m_param[[n]], m_nmb_LY)  # columns are m_param, nmbs_s1 and nmb_s2 
  
  
    m_nmb_QALY <- NMB_function(wtp    = WTP,
                               effect = l_res[[n]]$res_qaly, 
                               costs  = l_res[[n]]$res_cost) #for NMB
  #m.nmb <- NMB_function2(wtp=WTP,effect=res.ly, costs=res.cost) #for NHB (here WTP cannot be 0)
  l_df_param_nmb_QALY[[n]] <- data.frame(l_m_param[[n]], m_nmb_QALY)  # columns are m_param, nmbs_s1 and nmb_s2 
  
  #Specify strategies 
  nmb_LY   <- data.frame(m_nmb_LY)
  nmb_QALY <- data.frame(m_nmb_QALY)
  
   # Specify parameters 
  theta <- data.frame(m_param)
  
   # sel.params = is indicating the number of parameters 1:1
  n_params_EVPPI <- ncol(theta)
  
 #Calculate population EVPPI
    v_evppi_LY[i] <- evppi_lrmm_pop(nmb = nmb_LY, 
                                      params = as.matrix(theta),  
                                      sel.params = (1 : n_params_EVPPI), 
                                      verbose = TRUE, 
                                      sel.gam = T, 
                                      pop = l_pop[[n]]) 
  
    v_evppi_QALY[i] <- evppi_lrmm_pop(nmb = nmb_QALY, 
                                      params = as.matrix(theta),  
                                      sel.params = (1 : n_params_EVPPI), 
                                      verbose = TRUE, 
                                      sel.gam = T, 
                                      pop = l_pop[[n]]) 

  
}
  l_df_evppi_pop[[n]] <- cbind(WTP = v_wtp,      # store the willingness to pay values
                                LY = v_evppi_LY,  # store evppi LY
                             QALY = v_evppi_QALY) # store the population evppi
}


#Print the result 
l_df_evppi_pop 


# export the EVPI data 
save(l_df_evppi_pop, file = "../output/l_df_evppi_pop.rda")  

```


### 9.6.3.2.1 Plot EVPPI
```{r}
#load(file = "../output/l_df_evppi_pop.rda")
l_evppi_obj_LY <- l_evppi_obj_QALY <- list()

for(n in v_names_trt){
  
  evpppi_obj <- l_df_evppi_pop[[n]][, c(1,2)]
  evpppi_obj <- as.data.frame(evpppi_obj)

  l_evppi_obj_LY[[n]] <- evpppi_obj
    
  # 1. Open png file
  png(paste("../figures/EVPPI_LY", "_", remove_date_from_name(n), ".png", sep =""))

  # 2. Create the plot
  p <- plot(evpppi_obj,
            type = "l",
          txtsize = 16, 
          effect_units = "LY", 
          currency = "Dollars ($)",
          xbreaks = seq(0, 200, by = 10), 
          ylim = c(0, max(evpppi_obj$LY)))
  p
  
        # 3. Close the file
    dev.off()
  
  evpppi_obj <- l_df_evppi_pop[[n]][, c(1,3)]
  evpppi_obj <- as.data.frame(evpppi_obj)
  l_evppi_obj_QALY[[n]] <- evpppi_obj
  
  # 1. Open pgn file
  png(paste("../figures/EVPPI_QALY", "_", remove_date_from_name(n), ".png", sep =""))

  # 2. Create the plot
  p <- plot(evpppi_obj,
            type = "l",
          txtsize = 16, 
          effect_units = "QALY", 
          currency = "Dollars ($)",
          xbreaks = seq(0, 200, by = 10), 
          ylim = c(0, max(evpppi_obj$QALY)))
  p
  
        # 3. Close the file
    dev.off()
    
}


save(l_evppi_obj_LY, file = "../output/l_evppi_obj_LY.RData")

save(l_evppi_obj_QALY, file = "../output/l_evppi_obj_QALY.RData")

```




###  9.6.3.2.1.1 Plot EVPI with EVPPI
```{r}

for(n in v_names_trt){
currency <- "$"
  
plot_EVPI <- ggplot(data = l_evpi_obj_QALY[[n]],
         aes_(x = as.name("WTP"), y = as.name("EVPI_QALY"))) +
    geom_line() +
    xlab(paste("Willingness to Pay (Thousand ", currency, "/", "QALY", ")", sep = "")) +
    ylab(paste("EVPI (", currency, ")", sep = ""))


plot_EVPPI <- ggplot(data = l_evppi_obj_QALY[[n]],
         aes_(x = as.name("WTP"), y = as.name("QALY"))) +
    geom_line() +
    xlab(paste("Willingness to Pay (Thousand ", currency, "/", "QALY", ")", sep = "")) +
    ylab(paste("EVPPI (", currency, ")", sep = ""))


ggarrange(plot_EVPI, plot_EVPPI,
 labels = c("A", "B"),
          ncol = 1, nrow = 2,
          common.legend = TRUE,
          legend = "bottom")

        ggsave(path = here("../figures"), filename = paste("plot_EVPI_EVPPI_QALY", "_", remove_date_from_name(n), ".png", sep =""))
        }


```



### 9.6.3.2.2 Table EVPPI 
```{r}
m_summary_pop_EVPPI_LY <- m_summary_pop_EVPPI_QALY<- matrix(data = NA, 
                                                            nrow = length(v_wtp), 
                                                            ncol = length(names(l_param_trt)),
                                                            dimnames = list(v_wtp, names(l_param_trt) ))


for(n in v_names_trt){
  m_summary_pop_EVPPI_LY[, n]   <- round(l_df_evppi_pop[[n]])[, "LY"]
  m_summary_pop_EVPPI_QALY[, n] <- round(l_df_evppi_pop[[n]])[, "QALY"]
}

df_summary_pop_EVPPI_LY   <- as.data.frame(m_summary_pop_EVPPI_LY)
df_summary_pop_EVPPI_QALY <- as.data.frame(m_summary_pop_EVPPI_QALY)


library(gridExtra)

### LY ####
# Show the figures
df_summary_pop_EVPPI_LY
save(df_summary_pop_EVPPI_LY, file = "../output/df_summary_pop_EVPPI_LY.rda")  
png("../figures/table_summary_pop_EVPPI_LY.png", width = 1300, height = 1000, bg = "white", pointsize = 30)
grid.table(df_summary_pop_EVPPI_LY)
dev.off()


### Report version ## LIFE YEARS
df_summary_pop_EVPPI_million <- round(df_summary_pop_EVPPI_LY/1e6, 0)
df_summary_pop_EVPPI_million_plot <- df_summary_pop_EVPPI_million[, v_names_trt_report_full]
colnames(df_summary_pop_EVPPI_million_plot) <- remove_date_from_name(colnames(df_summary_pop_EVPPI_million_plot))

png("../figures/table_summary_pop_EVPPI_LY_million.png", width = 1300, height = 600, bg = "white", pointsize = 30)
grid.table(df_summary_pop_EVPPI_million_plot)
dev.off()



### QALY ####

# Show the figures
df_summary_pop_EVPPI_QALY
save(df_summary_pop_EVPPI_QALY, file = "../output/df_summary_pop_EVPPI_QALY.rda")  
png("../figures/table_summary_pop_EVPPI_QALY.png", width = 1300, height = 1000, bg = "white", pointsize = 30)
grid.table(df_summary_pop_EVPPI_QALY)
dev.off()


### Report version ## QALY
df_summary_pop_EVPPI_million <- round(df_summary_pop_EVPPI_QALY/1e6, 0)

df_summary_pop_EVPPI_million_plot <- df_summary_pop_EVPPI_million[, v_names_trt_report_full]
colnames(df_summary_pop_EVPPI_million_plot) <- remove_date_from_name(colnames(df_summary_pop_EVPPI_million_plot))

png("../figures/table_summary_pop_EVPPI_QALY_million.png", width = 1300, height = 600, bg = "white", pointsize = 30)
grid.table(df_summary_pop_EVPPI_million_plot)
dev.off()


```


### 9.6.3.2.3.1 Summary table with PSA and EVPPI for QALY
```{r}
# Load data
#load(file = "./output/l_df_evppi_pop.rda")
#load(file = "./output/l_df_cea_PSA_QALY.rda")
#load(file = "./output/l_df_PSA_QALY.rda")
#load(file = "./output/l_pop_evpsi_rct_r.rda")

options(scipen = 999)

df_summary_cea_QALY

v_names_col_PSA   <- c(colnames(df_summary_cea_QALY), "EVPPI", "Future patients", "Current patients")

m_summary_cea_QALY_PSA <- matrix(data = NA, 
                                 ncol = length(v_names_col_PSA), 
                                 nrow = length(names(l_param_trt)),
                                 dimnames = list(names(l_param_trt), v_names_col_PSA))

# NOTE:
# Yes*  = Trt is dominant
# No*   = Trt is dominated by noTrt
# Yes** = Trt is cost-saving ICER > WTP
# No**  = Trt is cost-saving, but not enough that ICER > WTP


for(n in names(l_param_trt)){
  
  df_summary_f    <- l_df_cea_PSA_QALY[[n]]  
  df_evppi_pop_f  <- l_df_evppi_pop[[n]][, "QALY"]  # select the wtp and QALY columsn
  names(df_evppi_pop_f) <- l_df_evppi_pop[[n]][, "WTP"] 
  
  m_summary_cea_QALY_PSA[n, "EVPPI"]    <- df_evppi_pop_f[as.numeric(names(df_evppi_pop_f)) == (l_param_trt[[n]]$wtp)] # select EVPPI with for wtp
  m_summary_cea_QALY_PSA[n, "Incr NMB"] <- l_df_PSA_QALY[[n]]$iNMB[l_df_PSA_QALY[[n]]$Strategy == "trt"]
  m_summary_cea_QALY_PSA[n, "Incr NHB"] <- l_df_PSA_QALY[[n]]$iNHB[l_df_PSA_QALY[[n]]$Strategy == "trt"]
  
  m_summary_cea_QALY_PSA[n, "Future patients"]  <- l_pop[[n]]
  m_summary_cea_QALY_PSA[n, "Current patients"] <- l_pop_trial[[n]]
  
  # check if treatment is not dominated or dominant
  if(df_summary_f$Status[df_summary_f$Strategy == "trt"] == "D"){
    m_summary_cea_QALY_PSA[n, "Cost-effective"] <- "No*"
    m_summary_cea_QALY_PSA[n, "Incr effect Rx"] <- df_summary_f$Effect[df_summary_f$Strategy == "trt"] - df_summary_f$Effect[df_summary_f$Strategy == "notrt"]
    m_summary_cea_QALY_PSA[n, "Incr cost Rx"] <- df_summary_f$Cost[df_summary_f$Strategy   == "trt"] - df_summary_f$Cost[df_summary_f$Strategy   == "notrt"]
    
  } else if (df_summary_f$Status[df_summary_f$Strategy == "notrt"] == "D"){
    m_summary_cea_QALY_PSA[n, "Cost-effective"] <- "Yes*"
    m_summary_cea_QALY_PSA[n, "Incr effect Rx"] <- df_summary_f$Effect[df_summary_f$Strategy == "trt"] - df_summary_f$Effect[df_summary_f$Strategy == "notrt"]
    m_summary_cea_QALY_PSA[n, "Incr cost Rx"] <- df_summary_f$Cost[df_summary_f$Strategy   == "trt"] - df_summary_f$Cost[df_summary_f$Strategy   == "notrt"]
  } else if(!is.na(df_summary_f$ICER[df_summary_f$Strategy == "trt"]) & df_summary_f$ICER[df_summary_f$Strategy == "trt"] > l_param_trt[[n]]$wtp){
    m_summary_cea_QALY_PSA[n, "Cost-effective"] <- "No"
    m_summary_cea_QALY_PSA[n, "ICER"          ] <- df_summary_f$ICER[df_summary_f$Strategy == "trt"]
    m_summary_cea_QALY_PSA[n, "Incr effect Rx"] <- df_summary_f$Inc_Effect[df_summary_f$Strategy == "trt"] 
    m_summary_cea_QALY_PSA[n, "Incr cost Rx"] <- df_summary_f$Inc_Cost[df_summary_f$Strategy   == "trt"]
  } else if(!is.na(df_summary_f$ICER[df_summary_f$Strategy == "trt"]) & df_summary_f$ICER[df_summary_f$Strategy == "trt"] <= l_param_trt[[n]]$wtp){
    m_summary_cea_QALY_PSA[n, "Cost-effective"] <- "Yes"
    m_summary_cea_QALY_PSA[n, "ICER"       ] <- df_summary_f$ICER[df_summary_f$Strategy       == "trt"]
    m_summary_cea_QALY_PSA[n, "Incr effect Rx"] <- df_summary_f$Inc_Effect[df_summary_f$Strategy == "trt"]
    m_summary_cea_QALY_PSA[n, "Incr cost Rx"] <- df_summary_f$Inc_Cost[df_summary_f$Strategy   == "trt"]
  } else{
    m_summary_cea_QALY_PSA[n, "Cost-effective"] <- "Trt both lower costs & effects"
    m_summary_cea_QALY_PSA[n, "Incr effect Rx"] <- -1 * df_summary_f$Inc_Effect[df_summary_f$Strategy == "notrt"]
    m_summary_cea_QALY_PSA[n, "Incr cost Rx"] <- -1 * df_summary_f$Inc_Cost[df_summary_f$Strategy   == "notrt"]
    m_summary_cea_QALY_PSA[n, "ICER"] <-  df_summary_f$ICER[df_summary_f$Strategy  == "notrt"]
    
    if (round(df_summary_f$ICER[df_summary_f$Strategy       == "notrt"]) > l_param_trt[[n]]$wtp) {
    m_summary_cea_QALY_PSA[n, "Cost-effective"] <- "Yes**"
    } else { m_summary_cea_QALY_PSA[n, "Cost-effective"] <- "No**"}
  }
  df_summary_cea_QALY_PSA <- as.data.frame(m_summary_cea_QALY_PSA)
  # make all columns that are numbers numeric 
  df_summary_cea_QALY_PSA[, -1] <- data.frame(lapply(df_summary_cea_QALY_PSA[, -1], as.numeric))

}


# Save the df in the output folder
df_summary_cea_QALY_PSA
save(df_summary_cea_QALY_PSA, file = "../output/df_summary_cea_QALY_PSA.rda")  

# Format the table

df_summary_cea_QALY_PSA_plot <- format_table_summary(df_summary_cea_QALY_PSA, EVPPI = TRUE)

df_summary_cea_QALY_PSA_plot[is.na(df_summary_cea_QALY_PSA_plot)] <- "n/a"
png("../figures/table_summary_cea_PSA_QALY.png", width = 2000, height = 380, bg = "white", pointsize = 22)
grid.table(df_summary_cea_QALY_PSA_plot)
dev.off()


df_summary_cea_QALY_PSA_plot_subset <- format_table_summary(df_summary_cea_QALY_PSA, EVPPI = TRUE, v_names_subset = l_names$v_names_trt_report)
df_summary_cea_QALY_PSA_plot_subset[is.na(df_summary_cea_QALY_PSA_plot_subset)] <- "n/a"
png("../figures/table_summary_cea_PSA_QALY_report.png", width = 1500, height = 380, bg = "white", pointsize = 22)
grid.table(df_summary_cea_QALY_PSA_plot_subset)
dev.off()

png("../figures/table_summary_cea_PSA_QALY_report_trans.png", width = 2500, height = 580, bg = "white", pointsize = 22)
grid.table(t(df_summary_cea_QALY_PSA_plot_subset))
dev.off()


df_summary_cea_QALY_PSA_report <- df_summary_cea_QALY_PSA_plot_subset
df_summary_cea_QALY_PSA_report[is.na(df_summary_cea_QALY_PSA_report)] <- "n/a"
# Save the one for reporting
save(df_summary_cea_QALY_PSA_report, file = "../output/df_summary_cea_QALY_PSA_report.rda") 

# Load file
# load(file = "./output/df_summary_cea_QALY_PSA_report.rda")
```





### 9.6.3.2.3.2 Summary table with PSA and EVPPI for LY
```{r}
# Load data
#load(file = "./output/l_df_evppi_pop.rda")
#load(file = "./output/l_df_cea_PSA_LY.rda")
#load(file = "./output/l_df_PSA_LY.rda")
#load(file = "./output/l_pop_evpsi_rct_r.rda")

options(scipen = 999)

df_summary_cea_LY

v_names_col_PSA   <- c(colnames(df_summary_cea_LY), "EVPPI", "Future patients", "Current patients")

m_summary_cea_LY_PSA <- matrix(data = NA, 
                                 ncol = length(v_names_col_PSA), 
                                 nrow = length(names(l_param_trt)),
                                 dimnames = list(names(l_param_trt), v_names_col_PSA))

# NOTE:
# Yes*  = Trt is dominant
# No*   = Trt is dominated by noTrt
# Yes** = Trt is cost-saving ICER > WTP
# No**  = Trt is cost-saving, but not enough that ICER > WTP


for(n in names(l_param_trt)){
  
  df_summary_f    <- l_df_cea_PSA_LY[[n]]  
  df_evppi_pop_f  <- l_df_evppi_pop[[n]][, "LY"]  # select the wtp and LY columsn
  names(df_evppi_pop_f) <- l_df_evppi_pop[[n]][, "WTP"] 
  
  m_summary_cea_LY_PSA[n, "EVPPI"]    <- df_evppi_pop_f[as.numeric(names(df_evppi_pop_f)) == (l_param_trt[[n]]$wtp)] # select EVPPI with for wtp
  m_summary_cea_LY_PSA[n, "Incr NMB"] <- l_df_PSA_LY[[n]]$iNMB[l_df_PSA_LY[[n]]$Strategy == "trt"]
  m_summary_cea_LY_PSA[n, "Incr NHB"] <- l_df_PSA_LY[[n]]$iNHB[l_df_PSA_LY[[n]]$Strategy == "trt"]
  
  m_summary_cea_LY_PSA[n, "Future patients"]  <- l_pop[[n]]
  m_summary_cea_LY_PSA[n, "Current patients"] <- l_pop_trial[[n]]
  
  # check if treatment is not dominated or dominant
  if(df_summary_f$Status[df_summary_f$Strategy == "trt"] == "D"){
    m_summary_cea_LY_PSA[n, "Cost-effective"] <- "No*"
    m_summary_cea_LY_PSA[n, "Incr effect Rx"] <- df_summary_f$Effect[df_summary_f$Strategy == "trt"] - df_summary_f$Effect[df_summary_f$Strategy == "notrt"]
    m_summary_cea_LY_PSA[n, "Incr cost Rx"] <- df_summary_f$Cost[df_summary_f$Strategy   == "trt"] - df_summary_f$Cost[df_summary_f$Strategy   == "notrt"]
    
  } else if (df_summary_f$Status[df_summary_f$Strategy == "notrt"] == "D"){
    m_summary_cea_LY_PSA[n, "Cost-effective"] <- "Yes*"
    m_summary_cea_LY_PSA[n, "Incr effect Rx"] <- df_summary_f$Effect[df_summary_f$Strategy == "trt"] - df_summary_f$Effect[df_summary_f$Strategy == "notrt"]
    m_summary_cea_LY_PSA[n, "Incr cost Rx"] <- df_summary_f$Cost[df_summary_f$Strategy   == "trt"] - df_summary_f$Cost[df_summary_f$Strategy   == "notrt"]
  } else if(!is.na(df_summary_f$ICER[df_summary_f$Strategy == "trt"]) & df_summary_f$ICER[df_summary_f$Strategy == "trt"] > l_param_trt[[n]]$wtp){
    m_summary_cea_LY_PSA[n, "Cost-effective"] <- "No"
    m_summary_cea_LY_PSA[n, "ICER"          ] <- df_summary_f$ICER[df_summary_f$Strategy == "trt"]
    m_summary_cea_LY_PSA[n, "Incr effect Rx"] <- df_summary_f$Inc_Effect[df_summary_f$Strategy == "trt"] 
    m_summary_cea_LY_PSA[n, "Incr cost Rx"] <- df_summary_f$Inc_Cost[df_summary_f$Strategy   == "trt"]
  } else if(!is.na(df_summary_f$ICER[df_summary_f$Strategy == "trt"]) & df_summary_f$ICER[df_summary_f$Strategy == "trt"] <= l_param_trt[[n]]$wtp){
    m_summary_cea_LY_PSA[n, "Cost-effective"] <- "Yes"
    m_summary_cea_LY_PSA[n, "ICER"       ] <- df_summary_f$ICER[df_summary_f$Strategy       == "trt"]
    m_summary_cea_LY_PSA[n, "Incr effect Rx"] <- df_summary_f$Inc_Effect[df_summary_f$Strategy == "trt"]
    m_summary_cea_LY_PSA[n, "Incr cost Rx"] <- df_summary_f$Inc_Cost[df_summary_f$Strategy   == "trt"]
  } else{
    m_summary_cea_LY_PSA[n, "Cost-effective"] <- "Trt both lower costs & effects"
    m_summary_cea_LY_PSA[n, "Incr effect Rx"] <- -1 * df_summary_f$Inc_Effect[df_summary_f$Strategy == "notrt"]
    m_summary_cea_LY_PSA[n, "Incr cost Rx"] <- -1 * df_summary_f$Inc_Cost[df_summary_f$Strategy   == "notrt"]
    m_summary_cea_LY_PSA[n, "ICER"] <-  df_summary_f$ICER[df_summary_f$Strategy  == "notrt"]
    
    if (round(df_summary_f$ICER[df_summary_f$Strategy       == "notrt"]) > l_param_trt[[n]]$wtp) {
      m_summary_cea_LY_PSA[n, "Cost-effective"] <- "Yes**"
    } else { m_summary_cea_LY_PSA[n, "Cost-effective"] <- "No**"}
  }
  df_summary_cea_LY_PSA <- as.data.frame(m_summary_cea_LY_PSA)
  # make all columns that are numbers numeric 
  df_summary_cea_LY_PSA[, -1] <- data.frame(lapply(df_summary_cea_LY_PSA[, -1], as.numeric))
  
}


# Save the df in the output folder
df_summary_cea_LY_PSA
save(df_summary_cea_LY_PSA, file = "../output/df_summary_cea_LY_PSA.rda")  

# Format the table

df_summary_cea_LY_PSA_plot <- format_table_summary(df_summary_cea_LY_PSA, EVPPI = TRUE)

df_summary_cea_LY_PSA_plot[is.na(df_summary_cea_LY_PSA_plot)] <- "n/a"
png("../figures/table_summary_cea_PSA_LY.png", width = 2000, height = 380, bg = "white", pointsize = 22)
grid.table(df_summary_cea_LY_PSA_plot)
dev.off()


df_summary_cea_LY_PSA_plot_subset <- format_table_summary(df_summary_cea_LY_PSA, EVPPI = TRUE, v_names_subset = l_names$v_names_trt_report)
df_summary_cea_LY_PSA_plot_subset[is.na(df_summary_cea_LY_PSA_plot_subset)] <- "n/a"
png("../figures/table_summary_cea_PSA_LY_report.png", width = 1500, height = 380, bg = "white", pointsize = 22)
grid.table(df_summary_cea_LY_PSA_plot_subset)
dev.off()

png("../figures/table_summary_cea_PSA_LY_report_trans.png", width = 2500, height = 580, bg = "white", pointsize = 22)
grid.table(t(df_summary_cea_LY_PSA_plot_subset))
dev.off()


df_summary_cea_LY_PSA_report <- df_summary_cea_LY_PSA_plot_subset
df_summary_cea_LY_PSA_report[is.na(df_summary_cea_LY_PSA_report)] <- "n/a"
# Save the one for reporting
save(df_summary_cea_LY_PSA_report, file = "../output/df_summary_cea_LY_PSA_report.rda") 

```


###  9.6.4.1 Calculate EVSI for LY 
```{r}
# EVSI for groups of parameters for one WTP threshold
######################################################
options(scipen = 999)
################################################################################
## EVSI 
## Assuming an RCT ##
################################################################################
# Load data when not running the analysis
# load(file = "../output/l_m_Parameters.rda")
# load(file = "../output/l_res.rda")

# Add life years data 
df_summary_pop_EVPPI <- df_summary_pop_EVPPI_LY

# Select the strategies with EVPPI > 0 at the wtp threshold of use
rownames(df_summary_pop_EVPPI) <- as.numeric(rownames(df_summary_pop_EVPPI))

v_names_EVSI <- v_names_EVSI_LY <- colnames(df_summary_pop_EVPPI)[which(df_summary_pop_EVPPI[rownames(df_summary_pop_EVPPI) == l_param_trt[[1]]$wtp, ] > 0)]


n_strategies <- n_str
l_m_nmb <- l_m_nmb2 <- l_evpsi_rct_r_one_LY <- l_EVSI_retr_rct_LY <- list()
l_theta <- list()



for (n in v_names_EVSI){
  
  trt_effect <- l_param_trt[[n]]$trt_effect
  vent       <- l_param_trt[[n]]$vent
 
  m_Parameters <- l_m_Parameters[[n]]
  
  l_m_nmb[[n]] <- NMB_function(wtp = l_param_trt[[n]]$wtp, 
                            effect = l_res[[n]]$res_ly, 
                             costs =  l_res[[n]]$res_cost)
  
   df_param_nmb <- data.frame(l_m_nmb[[n]])

   n_sim <- nrow(l_m_nmb[[n]])

#### Loss Matrix ####  
# Find optimal strategy (d*) based on the highest expected net value
m_nmb2 <- l_m_nmb[[n]][, c(1:2)]
d_star <- which.max(colMeans(m_nmb2))
d_star

## Compute Loss matrix iterating over all strategies
loss <- as.matrix(m_nmb2 - m_nmb2[, d_star])
head(loss)

# Specify parameters
  
    if(vent == FALSE){
      if (trt_effect == "RR"){
          theta <- data.frame(m_Parameters[, c("rr_D_Trt_timespan1")]) 
      }
        if (trt_effect == "RD"){
          theta <- data.frame(m_Parameters[, c("rd_D_Trt_timespan1")]) 
        }
           if (trt_effect == "OR"){
             theta <- data.frame(m_Parameters[, c("or_D_Trt_timespan1")]) 
           }
         if (trt_effect == "HR"){
           theta <- data.frame(m_Parameters[, c("hr_D_Trt_timespan1")]) 
      }
    } else if (vent == TRUE){
            if (trt_effect == "RR"){
              theta <- data.frame(m_Parameters[, c("rr_D_Trt_timespan1_vent",
                                                        "rr_D_Trt_timespan1_novent")]) 
      }
        if (trt_effect == "RD"){
          theta <- data.frame(m_Parameters[, c("rd_D_Trt_timespan1_vent",
                                                        "rd_D_Trt_timespan1_novent")]) 
        }
           if (trt_effect == "OR"){
             theta <- data.frame(m_Parameters[, c("or_D_Trt_timespan1_vent",
                                                        "or_D_Trt_timespan1_novent")]) 
           }
         if (trt_effect == "HR"){
           theta <- data.frame(m_Parameters[, c("hr_D_Trt_timespan1_vent",
                                                        "hr_D_Trt_timespan1_novent")] )
      }
    }

l_theta[[n]] <- as.list(theta)

# Select parameters from theta

sel_params_rct <- length(colnames(theta))  


### Estimate linear metamodel of two strategies
lmm1 <- gam(as.formula(paste("loss[, 1] ~ s(", colnames(theta)[sel_params_rct], ")")),
            data = theta)
lmm2 <- gam(as.formula(paste("loss[, 2] ~ s(", colnames(theta)[sel_params_rct], ")")),
            data = theta)


#### Compute EVSI on the chosen parameter ####
## Initial Sample size of the parameter
n0 <- c(1063)

# Vector with samples to evaluate EVPSI for an RCT
n_rct <- seq(0, 10000, by = 100)
n_rct_samples <- length(n_rct)

# Initialize EVPSI matrix for a combination of parameters
evpsi_rct_r_one <- data.frame(Study = "RCT", 
                              N     = n_rct, 
                              EVPSI = matrix(0, nrow = n_rct_samples, ncol = 1))

for (n_Samp in 1:n_rct_samples){
  
  ### Compute expected conditional loss for each strategy
  Ltilde1 <- predict.ga(lmm1, n = n_rct[n_Samp], n0 = n0)
  Ltilde2 <- predict.ga(lmm2, n = n_rct[n_Samp], n0 = n0)
  
  ## Combine losses into one matrix
  loss_tilde <- cbind(Ltilde1, Ltilde2)
  
  ### Apply EVSI equation
  evsi <- mean(rowMaxs(loss_tilde))
  
  evpsi_rct_r_one$EVPSI[n_Samp] <- evsi
 } # close loop for nSamp

 l_evpsi_rct_r_one_LY[[n]] <-  evpsi_rct_r_one #  save the results or all n_Samp stored 
 
#Save the results for EVSI per person
l_EVSI_retr_rct_LY[[n]] <- data.frame(l_evpsi_rct_r_one_LY[[n]]$N, l_evpsi_rct_r_one_LY[[n]]$EVPSI)

} #close loop for treatments 

# save the file
save(l_evpsi_rct_r_one_LY, file = "../output/l_evpsi_rct_r_one_LY.rda")

# Make a dataframe
df_evspi <- l_evpsi_rct_r_one_LY %>% reduce(inner_join, by = c("N", "Study"))  
df_evspi[, -c(1, 2)] <- round(df_evspi[, -c(1, 2)])  # round the values
colnames(df_evspi) <- c("Study", "N", names(l_evpsi_rct_r_one_LY))
df_evspi_plot <- df_evspi
colnames(df_evspi_plot) <- c("Study", "N", remove_date_from_name(colnames(df_evspi_plot[, -c(1, 2)])))


save(df_evspi_plot, file = "../output/df_evspi_plot_LY.rda")

png("../figures/table_df_evspi_plot_LY.png", width = 800, height = 2600, bg = "white", pointsize = 30)
grid.table(df_evspi_plot)
dev.off()
```


###  9.6.4.1 Calculate EVSI for QALY 
```{r}
# EVSI for groups of parameters for one WTP threshold
######################################################
options(scipen = 999)

################################################################################
## EVSI 
## Assuming an RCT ##
################################################################################
# Load data when not running the analysis
# load(file = "../output/l_m_Parameters.rda")
# load(file = "../output/l_res.rda")

 ##QALY###

df_summary_pop_EVPPI <- df_summary_pop_EVPPI_QALY

# Select the strategies with EVPPI > 0 at the wtp threshold of use
rownames(df_summary_pop_EVPPI) <- as.numeric(rownames(df_summary_pop_EVPPI))

v_names_EVSI <- v_names_EVSI_QALY <- colnames(df_summary_pop_EVPPI)[which(df_summary_pop_EVPPI[rownames(df_summary_pop_EVPPI) == l_param_trt[[1]]$wtp, ] > 0)]


n_strategies <- n_str
l_m_nmb <- l_m_nmb2 <- l_evpsi_rct_r_one_QALY <- l_EVSI_retr_rct_QALY <- list()
l_theta <- list()



for (n in v_names_EVSI){
  
  trt_effect <- l_param_trt[[n]]$trt_effect
  vent       <- l_param_trt[[n]]$vent
 
  m_Parameters <- l_m_Parameters[[n]]
  
  l_m_nmb[[n]] <- NMB_function(wtp = l_param_trt[[n]]$wtp, 
                            effect = l_res[[n]]$res_qaly,   ##QALY###
                             costs =  l_res[[n]]$res_cost)
  
#m.nmb <- NMB_function2(wtp=WTP,effect=res.ly, costs=res.cost) #for NHB (here WTP cannot be 0)
   df_param_nmb <- data.frame(l_m_nmb[[n]])

   n_sim <- nrow(l_m_nmb[[n]])

#### Loss Matrix ####  
# Find optimal strategy (d*) based on the highest expected net value
m_nmb2 <- l_m_nmb[[n]][, c(1:2)]
d_star <- which.max(colMeans(m_nmb2))
d_star

## Compute Loss matrix iterating over all strategies
loss <- as.matrix(m_nmb2 - m_nmb2[, d_star])
head(loss)

# Specify parameters
  
    if(vent == FALSE){
      if (trt_effect == "RR"){
          theta <- data.frame(m_Parameters[, c("rr_D_Trt_timespan1")]) 
      }
        if (trt_effect == "RD"){
          theta <- data.frame(m_Parameters[, c("rd_D_Trt_timespan1")]) 
        }
           if (trt_effect == "OR"){
             theta <- data.frame(m_Parameters[, c("or_D_Trt_timespan1")]) 
           }
         if (trt_effect == "HR"){
           theta <- data.frame(m_Parameters[, c("hr_D_Trt_timespan1")]) 
      }
    } else if (vent == TRUE){
            if (trt_effect == "RR"){
              theta <- data.frame(m_Parameters[, c("rr_D_Trt_timespan1_vent",
                                                        "rr_D_Trt_timespan1_novent")]) 
      }
        if (trt_effect == "RD"){
          theta <- data.frame(m_Parameters[, c("rd_D_Trt_timespan1_vent",
                                                        "rd_D_Trt_timespan1_novent")]) 
        }
           if (trt_effect == "OR"){
             theta <- data.frame(m_Parameters[, c("or_D_Trt_timespan1_vent",
                                                        "or_D_Trt_timespan1_novent")]) 
           }
         if (trt_effect == "HR"){
           theta <- data.frame(m_Parameters[, c("hr_D_Trt_timespan1_vent",
                                                        "hr_D_Trt_timespan1_novent")] )
      }
    }

l_theta[[n]] <- as.list(theta)

# Select parameters from theta

sel_params_rct <- length(colnames(theta))  


### Estimate linear metamodel of two strategies
lmm1 <- gam(as.formula(paste("loss[, 1] ~ s(", colnames(theta)[sel_params_rct], ")")),
            data = theta)
lmm2 <- gam(as.formula(paste("loss[, 2] ~ s(", colnames(theta)[sel_params_rct], ")")),
            data = theta)


#### Compute EVSI on the chosen parameter ####
## Initial Sample size of the parameter
n0 <- c(1063)

# Vector with samples to evaluate EVPSI for an RCT
n_rct <- seq(0, 10000, by = 100)
n_rct_samples <- length(n_rct)

# Initialize EVPSI matrix for a combination of parameters
evpsi_rct_r_one <- data.frame(Study = "RCT", 
                              N     = n_rct, 
                              EVPSI = matrix(0, nrow = n_rct_samples, ncol = 1))

for (n_Samp in 1:n_rct_samples){
  
  ### Compute expected conditional loss for each strategy
  Ltilde1 <- predict.ga(lmm1, n = n_rct[n_Samp], n0 = n0)
  Ltilde2 <- predict.ga(lmm2, n = n_rct[n_Samp], n0 = n0)
  
  ## Combine losses into one matrix
  loss_tilde <- cbind(Ltilde1, Ltilde2)
  
  ### Apply EVSI equation
  evsi <- mean(rowMaxs(loss_tilde))
  
  evpsi_rct_r_one$EVPSI[n_Samp] <- evsi
 } # close loop for nSamp

 l_evpsi_rct_r_one_QALY[[n]] <-  evpsi_rct_r_one #  save the results or all n_Samp stored 
 
#Save the results for EVSI per person
l_EVSI_retr_rct_QALY[[n]] <- data.frame(l_evpsi_rct_r_one_QALY[[n]]$N, l_evpsi_rct_r_one_QALY[[n]]$EVPSI)

} #close loop for treatments 

# save the file
save(l_evpsi_rct_r_one_QALY, file = "../output/l_evpsi_rct_r_one_QALY.rda")

# Make a dataframe
df_evspi <- l_evpsi_rct_r_one_QALY %>% reduce(inner_join, by = c("N", "Study"))  
df_evspi[, -c(1, 2)] <- round(df_evspi[, -c(1, 2)])  # round the values
colnames(df_evspi) <- c("Study", "N", names(l_evpsi_rct_r_one_QALY))
df_evspi_plot <- df_evspi
colnames(df_evspi_plot) <- c("Study", "N", remove_date_from_name(colnames(df_evspi_plot[, -c(1, 2)])))


save(df_evspi_plot, file = "../output/df_evspi_plot_QALY.rda")

png("../figures/table_df_evspi_plot_QALY.png", width = 800, height = 2600, bg = "white", pointsize = 30)
grid.table(df_evspi_plot)
dev.off()

```



### 9.6.4.2 Calculate pop EVSI
```{r}
#load(file = "../output/l_evpsi_rct_r_one.rda")

l_pop_evpsi_rct_r_LY <- l_pop_evpsi_rct_r_QALY <- list()

for (n in v_names_EVSI_LY){
### Population Values
## Total population (can be presented in Millions)
tot_pop <- l_pop[[n]] 

#########################################
## Population EVPSI
#########################################
# RCT
pop_evpsi_rct_r             <- l_evpsi_rct_r_one_LY[[n]]
pop_evpsi_rct_r$popEVPSI    <- pop_evpsi_rct_r$EVPSI * tot_pop
l_pop_evpsi_rct_r_LY[[n]]   <- pop_evpsi_rct_r
}

save(l_pop_evpsi_rct_r_LY, file = "../output/l_pop_evpsi_rct_r_LY.rda")



for (n in v_names_EVSI_QALY){
### Population Values
## Total population (can be presented in Millions)
tot_pop <- l_pop[[n]] 

#########################################
## Population EVPSI
#########################################
# RCT
pop_evpsi_rct_r               <- l_evpsi_rct_r_one_QALY[[n]]
pop_evpsi_rct_r$popEVPSI      <- pop_evpsi_rct_r$EVPSI * tot_pop
l_pop_evpsi_rct_r_QALY[[n]]   <- pop_evpsi_rct_r
}

save(l_pop_evpsi_rct_r_QALY, file = "../output/l_pop_evpsi_rct_r_QALY.rda")



```


###  9.6.5  Plot EVPSI per person for RCT
```{r}
#load(file = "../output/l_pop_evpsi_rct_r.rda")

for (n in v_names_EVSI_LY){

# Plot EVSI by study design for RCT
ggplot(l_evpsi_rct_r_one_LY[[n]], aes(x = N, y = EVPSI)) +  # color = Parameter
  geom_line() +
  geom_point() +
  facet_wrap(~ Study, scales = "free_x") +
  ggtitle("EVSI per person for RCT") +
  xlab("Sample size (n)") +
  ylab("$") +
  scale_x_continuous(breaks = number_ticks(5)) + 
  scale_y_continuous(breaks = number_ticks(6), labels = dollar) + 
  theme_bw(base_size = 14)

ggsave(path = "../figures", filename = paste("EVPSI_RCT_LY", "_", remove_date_from_name(n), ".png", sep =""))

}


for (n in v_names_EVSI_QALY){

# Plot EVSI by study design for RCT
ggplot(l_evpsi_rct_r_one_QALY[[n]], aes(x = N, y = EVPSI)) +  # color = Parameter
  geom_line() +
  geom_point() +
  facet_wrap(~ Study, scales = "free_x") +
  ggtitle("EVSI per person for RCT") +
  xlab("Sample size (n)") +
  ylab("$") +
  scale_x_continuous(breaks = number_ticks(5)) + 
  scale_y_continuous(breaks = number_ticks(6), labels = dollar) + 
  theme_bw(base_size = 14)

ggsave(path = "../figures", filename = paste("EVPSI_RCT_QALY", "_", remove_date_from_name(n), ".png", sep =""))

}

```




###  9.6.6 Calculate net value of overall strategy of new therapies 
#####  9.6.6.1 QALY 
```{r}
#load(file = "../output/l_df_PSA_QALY.rda")
#load(file = "../output/l_pop.rda")
l_enb <- l_oss <- list()


v_names_rows_enb <- c("Optimal strategy", 
                      "Optimal sample size (N*)", 
                      "Net value for:", 
                        "OIR", 
                        "AWR", 
                        "Approve", 
                        "Reject",
                      "Equation parameters:",
                      "Costs RCT",
                      "EVSI N*",
                      "Below values for sample size of N = 2500", 
                      "Costs RCT N=2500",
                      "EVSI N=2500",
                        "AWR N=2500", 
                        "OIR N=2500")

m_enb <- matrix(data = NA,
                nrow = length(v_names_rows_enb),
                ncol = length(v_names_trt_report_full),
                dimnames = list(v_names_rows_enb, v_names_trt_report_full))

df_enb <- as.data.frame(m_enb)

#The optimal sample size (OSS) is determined by maximizing the function in the quadrant with respect to n. 

for (n in v_names_trt_report_full){
options(scipen = 999)
  
# select the values needed in the equations 
iNMB               <- l_df_PSA_QALY[[n]]$iNMB[2] 
wtp                <- l_param_trt[[n]]$wtp
EVPPI              <- l_df_evppi_pop[[n]][, "QALY"][l_df_evppi_pop[[n]][, "WTP"] == wtp]

l_pop_evpsi_rct_r <- l_pop_evpsi_rct_r_QALY


n_patients_current <- l_pop_all[[n]]$n_patients_current
n_patients_future  <- l_pop_all[[n]]$n_patients_future   
n_p_rct_ratio      <- 0.5  # proportion of the RCT participants in the treatment arm
c_RCT_fixed        <- l_param_trt[[n]]$c_RCT_fixed
c_RCT_ppo          <- l_param_trt[[n]]$c_RCT_ppo
n_samp_size        <- n_rct  # vector of sample size values
n_samp_size_real   <- 2500   # The most realistic sample size - used to report if optimal sample size > 2500

  df_enb["Reject", n] <- 0

  if(iNMB <= 0 & EVPPI <= 0){ # Reject
  df_enb["Optimal strategy", n] <- "Reject"   # store the strategy
  
  #### Calculations for the OIR and AWR and approve
  EVPSI <- 0  # Set EVPSI on zero
  
  ## Approve ##
  df_enb["Approve", n] <- calc_enb_approve(iNB = iNMB,
                            n_patients_current = n_patients_current,
                             n_patients_future = n_patients_future)
 ## Only in research ##
  v_enb_OIR             <- calc_enb_OIR(iNB = iNMB,
                                  rct_ratio = n_p_rct_ratio,
                                sample_size = n_samp_size,
                                      EVPSI = EVPSI,
                         n_patients_future = n_patients_future,
                               c_RCT_fixed = c_RCT_fixed,
                                  c_RCT_pp = c_RCT_ppo)
  df_enb["OIR", n] <- v_enb_OIR[which.max(v_enb_OIR)] # select the maximum value. Note in negative values this is the least negative. 
  # this can result in a sample size of zero if that is the least 
 
  ## Approve with research ##
  v_enb_AWR <-  calc_enb_AWR(iNB = iNMB,
                             rct_ratio = n_p_rct_ratio,
                             sample_size = n_samp_size,
                             EVPSI = EVPSI,
                             n_patients_future = n_patients_future,
                             n_patients_current = n_patients_current,
                             c_RCT_fixed = c_RCT_fixed,
                             c_RCT_pp = c_RCT_ppo)
  
  df_enb["AWR", n] <- v_enb_AWR[which.max(v_enb_AWR)]
  
  
  
} else if (iNMB > 0 & EVPPI <= 0){
   # Store the strategy 
  df_enb["Optimal strategy", n] <- "Approve"   
  
  # Calculate the expected net value for approve
  df_enb["Approve", n] <- calc_enb_approve(iNB = iNMB,
                          n_patients_current = n_patients_current,
                          n_patients_future = n_patients_future)
  
  #### Calculations for the OIR and AWR 
  EVPSI <- 0
 
  v_enb_OIR <- calc_enb_OIR(iNB = iNMB,
                            rct_ratio = n_p_rct_ratio,
                            sample_size = n_samp_size,
                            EVPSI = EVPSI,
                            n_patients_future = n_patients_future,
                            c_RCT_fixed = c_RCT_fixed,
                            c_RCT_pp = c_RCT_ppo)
  
  df_enb["OIR", n] <- v_enb_OIR[which.max(v_enb_OIR)]
  
  v_enb_AWR <-  calc_enb_AWR(iNB = iNMB,
                             rct_ratio = n_p_rct_ratio,
                             sample_size = n_samp_size,
                             EVPSI = EVPSI,
                             n_patients_current = n_patients_current,
                             n_patients_future = n_patients_future,
                             c_RCT_fixed = c_RCT_fixed,
                             c_RCT_pp = c_RCT_ppo)

  df_enb["AWR", n] <- v_enb_AWR[which.max(v_enb_AWR)]
  
  
} else if(iNMB <= 0 & EVPPI > 0){ 
  EVPSI        <- l_pop_evpsi_rct_r[[n]]$EVPSI # select EVPSI per person
  names(EVPSI) <- l_pop_evpsi_rct_r[[n]]$N

    # Calculate only in research 
    v_enb_OIR <- calc_enb_OIR(iNB = iNMB, 
                              rct_ratio = n_p_rct_ratio, 
                              sample_size = n_samp_size, 
                              EVPSI = EVPSI, 
                              n_patients_future = n_patients_future, 
                              c_RCT_fixed = c_RCT_fixed, 
                              c_RCT_pp = c_RCT_ppo)
    oss <- n_samp_size[which.max(v_enb_OIR)]    
    
    df_enb["OIR", n] <- v_enb_OIR[which.max(v_enb_OIR)]
    
  ## Approve ##
  df_enb["Approve", n] <- calc_enb_approve(iNB = iNMB,
                          n_patients_current = n_patients_current,
                          n_patients_future = n_patients_future)
  
  v_enb_AWR<- calc_enb_AWR(iNB = iNMB,
                                    rct_ratio = n_p_rct_ratio,
                                    sample_size = n_samp_size,
                                    EVPSI = EVPSI,
                                    n_patients_current = n_patients_current,
                                    n_patients_future = n_patients_future,
                                    c_RCT_fixed = c_RCT_fixed,
                                    c_RCT_pp = c_RCT_ppo)
   df_enb["AWR",   n] <- v_enb_AWR[which.max(v_enb_AWR)]
    

  if(oss > 0){ 
    df_enb["Optimal strategy", n]         <- "OIR"   # store the strategy       
    #df_enb["OIR", n]                      <- v_enb_OIR[which.max(v_enb_OIR)]
    df_enb["Optimal sample size (N*)", n] <- oss
    df_enb["Costs RCT", n]                <- round((c_RCT_fixed + oss  * c_RCT_ppo)) 
    df_enb["EVSI N*", n]                 <- round(EVPSI[which(names(EVPSI) == oss)])
    
}  else {
      df_enb["Optimal strategy", n] <- "Reject"   # store the strategy 
      df_enb["Reject", n] <- 0
      #df_enb["OIR", n]                      <- v_enb_OIR[which.max(v_enb_OIR)]
      
      #df_enb["OIR", n]    <- "Worse than Reject" # If you decided OIR, it costs you a lot of money
}
  
  if(oss > 2500){
        df_enb["EVSI N=2500", n]   <- round(EVPSI[which(names(EVPSI) == n_samp_size_real)])
    df_enb["Costs RCT N=2500", n]   <- round((c_RCT_fixed + n_samp_size_real * c_RCT_ppo)) 
  
    df_enb["OIR N=2500",   n]  <- calc_enb_OIR(iNB = iNMB, 
                                    rct_ratio = n_p_rct_ratio, 
                              sample_size = n_samp_size_real, 
                              EVPSI =  EVPSI[which(names(EVPSI) == n_samp_size_real)], 
                              n_patients_future = n_patients_future, 
                              c_RCT_fixed = c_RCT_fixed, 
                              c_RCT_pp = c_RCT_ppo)
    
    df_enb["AWR N=2500",   n] <- calc_enb_AWR(iNB = iNMB,
                                    rct_ratio = n_p_rct_ratio,
                                    sample_size = n_samp_size_real,
                                    EVPSI = EVPSI[which(names(EVPSI) == n_samp_size_real)],
                                    n_patients_current = n_patients_current,
                                    n_patients_future = n_patients_future,
                                    c_RCT_fixed = c_RCT_fixed,
                                    c_RCT_pp = c_RCT_ppo)

  }
    
      
  l_enb[[n]] <- data.frame(N     = n_samp_size, 
                           Study = "RCT",
                            cRCT = round((c_RCT_fixed + oss * c_RCT_ppo)),
                            EVPSI = round(EVPSI),
                  Implementation = "OIR",
                           ENB   = v_enb_OIR,
                           nstar = oss,
                        ENBnstar = v_enb_OIR[which.max(v_enb_OIR)]) 

  
  
  
} else if(iNMB > 0 & EVPPI > 0){
  
    EVPSI        <- l_pop_evpsi_rct_r[[n]]$EVPSI # select EVPSI per person
    names(EVPSI) <- l_pop_evpsi_rct_r[[n]]$N
  
    v_enb_AWR <-  calc_enb_AWR(iNB = iNMB,
                                    rct_ratio = n_p_rct_ratio,
                                    sample_size = n_samp_size,
                                    EVPSI = EVPSI,
                                    n_patients_current = n_patients_current,
                                    n_patients_future = n_patients_future,
                                    c_RCT_fixed = c_RCT_fixed,
                                    c_RCT_pp = c_RCT_ppo)
    oss <- n_samp_size[which.max(v_enb_AWR)] 
    
    df_enb["AWR", n]  <- round(v_enb_AWR[which.max(v_enb_AWR)]) 
    
    # Calculate only in research 
    v_enb_OIR <- calc_enb_OIR(iNB = iNMB, 
                              rct_ratio = n_p_rct_ratio, 
                              sample_size = n_samp_size, 
                              EVPSI = EVPSI, 
                              n_patients_future = n_patients_future, 
                              c_RCT_fixed = c_RCT_fixed, 
                              c_RCT_pp = c_RCT_ppo)
  
    df_enb["OIR", n] <- v_enb_OIR[which.max(v_enb_OIR)]

    l_enb[[n]] <- data.frame(N   = n_samp_size, 
                             Study = "RCT",
                             cRCT = round((c_RCT_fixed + oss * c_RCT_ppo)),
                             EVPSI = EVPSI,
                             Implementation = "AWR",
                             ENB = v_enb_AWR,
                             nstar = oss)


  # Calculate the expected net value for approve
  df_enb["Approve", n] <- calc_enb_approve(iNB = iNMB,
                                           n_patients_current = n_patients_current,
                                           n_patients_future = n_patients_future)
      
    if(df_enb["AWR", n] > df_enb["Approve", n]){ 
      df_enb["Optimal strategy", n]    <- "AWR"   # store the strategy     
      df_enb["AWR", n]                 <- round(v_enb_AWR[which.max(v_enb_AWR)]) 
      df_enb["Optimal sample size (N*)", n] <- oss
      df_enb["Costs RCT", n]           <- round((c_RCT_fixed + oss * c_RCT_ppo))     
      df_enb["EVSI N*", n]            <- round(EVPSI[which(names(EVPSI) == oss)])

}  else{
      df_enb["Optimal strategy", n] <- "Approve"   # store the strategy 
      df_enb["AWR", n]              <- round(v_enb_AWR[which.max(v_enb_AWR)]) 
       # Calculate the expected net value for approve
       df_enb["Approve", n]         <- calc_enb_approve(iNB = iNMB,
                                           n_patients_current = n_patients_current,
                                           n_patients_future = n_patients_future)
}
  if(oss > 2500){
          
      df_enb["Costs RCT N=2500", n]    <- round((c_RCT_fixed + 2500 * c_RCT_ppo))
      df_enb["EVSI N=2500", n]        <- round(EVPSI[which(names(EVPSI) == 2500)])
      df_enb["AWR N=2500", n]          <- calc_enb_AWR(iNB = iNMB,
                                                  rct_ratio = n_p_rct_ratio,
                                                  sample_size = 2500,
                                                  EVPSI = EVPSI[which(names(EVPSI) == 2500)],
                                                  n_patients_current = n_patients_current,
                                                  n_patients_future = n_patients_future,
                                                  c_RCT_fixed = c_RCT_fixed,
                                                  c_RCT_pp = c_RCT_ppo)
      
          
    df_enb["OIR N=2500",   n]  <- calc_enb_OIR(iNB = iNMB, 
                              rct_ratio = n_p_rct_ratio, 
                              sample_size = 2500, 
                              EVPSI =  EVPSI[which(names(EVPSI) == 2500)], 
                              n_patients_future = n_patients_future, 
                              c_RCT_fixed = c_RCT_fixed, 
                              c_RCT_pp = c_RCT_ppo)
  }
}

}


save(df_enb, file = "../output/df_enb_QALY.rda")


# Note: this step is only done for the studies that show positive EVPPI
df_oss <- matrix(NA, nrow = 3, ncol = length(names(l_enb)), 
                 dimnames = list(c("Implementation", "MaxENBS", "Nstar"), names(l_enb)))


for (n in names(l_enb)){
#### Optimal Sample Size (OSS), n*
l_oss[[n]] <- summarise(group_by(l_enb[[n]], Study),
                        Implementation = Implementation[1],
                      MaxENBS = max(ENB),
                      Nstar   = N[which.max(ENB)])

df_oss[, n] <- t(l_oss[[n]]) # transpose the data and store in a dataframe
}


df_enb_plot <- df_enb
colnames(df_enb_plot) <- remove_date_from_name(colnames(df_enb_plot))

# New order table 
df_enb_plot_order <- df_enb_plot[, c(which(df_enb_plot["Optimal strategy", ] == "OIR"),
which(df_enb_plot["Optimal strategy", ] == "AWR"),
which(df_enb_plot["Optimal strategy", ] == "Approve"),
which(df_enb_plot["Optimal strategy", ] == "Reject"))]


df_enb_plot[is.na(df_enb_plot)] <- "n/a"
png("../figures/table_enb_QALY.png", width = 1200, height = 600, bg = "white", pointsize = 22)
grid.table(df_enb_plot_order)
dev.off()


save(l_enb,       file = "../output/l_enb_QALY.rda")
save(df_enb,      file = "../output/df_enb_QALY.rda")
save(df_enb_plot, file = "../output/df_enb_plot_QALY.rda")

l_enb_QALY <- l_enb
df_enb_QALY <- df_enb
df_enb_plot_QALY <- df_enb_plot

```



#####  9.6.6.1 LY 
```{r}
#load(file = "../output/l_df_PSA_LY.rda")
#load(file = "../output/l_pop.rda")
l_enb <- l_oss <- list()


v_names_rows_enb <- c("Optimal strategy", 
                      "Optimal sample size (N*)", 
                      "Net value for:", 
                        "OIR", 
                        "AWR", 
                        "Approve", 
                        "Reject",
                      "Equation parameters:",
                      "Costs RCT",
                      "EVSI N*",
                      "Below values for sample size of N = 2500", 
                      "Costs RCT N=2500",
                      "EVSI N=2500",
                        "AWR N=2500", 
                        "OIR N=2500")

m_enb <- matrix(data = NA,
                nrow = length(v_names_rows_enb),
                ncol = length(v_names_trt_report_full),
                dimnames = list(v_names_rows_enb, v_names_trt_report_full))

df_enb <- as.data.frame(m_enb)

#The optimal sample size (OSS) is determined by maximizing the function in the quadrant with respect to n. 

for (n in v_names_trt_report_full){
options(scipen = 999)
  
  names(l_df_evppi_pop[[n]]) <- l_df_evppi_pop[[n]][, 1]
  
  #### NOTE: CHECK LIFE YEARS
# select the values needed in the equations 
iNMB               <- l_df_PSA_LY[[n]]$iNMB[2] 
wtp                <- l_param_trt[[n]]$wtp
EVPPI              <- l_df_evppi_pop[[n]][, "QALY"][l_df_evppi_pop[[n]][, "WTP"] == wtp]
l_pop_evpsi_rct_r <- l_pop_evpsi_rct_r_LY

n_patients_current <- l_pop_all[[n]]$n_patients_current
n_patients_future  <- l_pop_all[[n]]$n_patients_future   
n_p_rct_ratio      <- 0.5  # proportion of the RCT participants in the treatment arm
c_RCT_fixed        <- l_param_trt[[n]]$c_RCT_fixed
c_RCT_ppo          <- l_param_trt[[n]]$c_RCT_ppo
n_samp_size        <- n_rct  # vector of sample size values
n_samp_size_real   <- 2500   # The most realistic sample size - used to report if optimal sample size > 2500

  df_enb["Reject", n] <- 0

  if(iNMB <= 0 & EVPPI <= 0){ # Reject
  df_enb["Optimal strategy", n] <- "Reject"   # store the strategy
  
  #### Calculations for the OIR and AWR and approve
  EVPSI <- 0  # Set EVPSI on zero
  
  ## Approve ##
  df_enb["Approve", n] <- calc_enb_approve(iNB = iNMB,
                            n_patients_current = n_patients_current,
                             n_patients_future = n_patients_future)
 ## Only in research ##
  v_enb_OIR             <- calc_enb_OIR(iNB = iNMB,
                                  rct_ratio = n_p_rct_ratio,
                                sample_size = n_samp_size,
                                      EVPSI = EVPSI,
                         n_patients_future = n_patients_future,
                               c_RCT_fixed = c_RCT_fixed,
                                  c_RCT_pp = c_RCT_ppo)
  df_enb["OIR", n] <- v_enb_OIR[which.max(v_enb_OIR)] # select the maximum value. Note in negative values this is the least negative. 
  # this can result in a sample size of zero if that is the least 
 
  ## Approve with research ##
  v_enb_AWR <-  calc_enb_AWR(iNB = iNMB,
                             rct_ratio = n_p_rct_ratio,
                             sample_size = n_samp_size,
                             EVPSI = EVPSI,
                             n_patients_future = n_patients_future,
                             n_patients_current = n_patients_current,
                             c_RCT_fixed = c_RCT_fixed,
                             c_RCT_pp = c_RCT_ppo)
  
  df_enb["AWR", n] <- v_enb_AWR[which.max(v_enb_AWR)]
  
  
  
} else if (iNMB > 0 & EVPPI <= 0){
   # Store the strategy 
  df_enb["Optimal strategy", n] <- "Approve"   
  
  # Calculate the expected net value for approve
  df_enb["Approve", n] <- calc_enb_approve(iNB = iNMB,
                          n_patients_current = n_patients_current,
                          n_patients_future = n_patients_future)
  
  #### Calculations for the OIR and AWR 
  EVPSI <- 0
 
  v_enb_OIR <- calc_enb_OIR(iNB = iNMB,
                            rct_ratio = n_p_rct_ratio,
                            sample_size = n_samp_size,
                            EVPSI = EVPSI,
                            n_patients_future = n_patients_future,
                            c_RCT_fixed = c_RCT_fixed,
                            c_RCT_pp = c_RCT_ppo)
  
  df_enb["OIR", n] <- v_enb_OIR[which.max(v_enb_OIR)]
  
  v_enb_AWR <-  calc_enb_AWR(iNB = iNMB,
                             rct_ratio = n_p_rct_ratio,
                             sample_size = n_samp_size,
                             EVPSI = EVPSI,
                             n_patients_current = n_patients_current,
                             n_patients_future = n_patients_future,
                             c_RCT_fixed = c_RCT_fixed,
                             c_RCT_pp = c_RCT_ppo)

  df_enb["AWR", n] <- v_enb_AWR[which.max(v_enb_AWR)]
  
  
} else if(iNMB <= 0 & EVPPI > 0){ 
  EVPSI        <- l_pop_evpsi_rct_r[[n]]$EVPSI # select EVPSI per person
  names(EVPSI) <- l_pop_evpsi_rct_r[[n]]$N

    # Calculate only in research 
    v_enb_OIR <- calc_enb_OIR(iNB = iNMB, 
                              rct_ratio = n_p_rct_ratio, 
                              sample_size = n_samp_size, 
                              EVPSI = EVPSI, 
                              n_patients_future = n_patients_future, 
                              c_RCT_fixed = c_RCT_fixed, 
                              c_RCT_pp = c_RCT_ppo)
    oss <- n_samp_size[which.max(v_enb_OIR)]    
    
    df_enb["OIR", n] <- v_enb_OIR[which.max(v_enb_OIR)]
    
  ## Approve ##
  df_enb["Approve", n] <- calc_enb_approve(iNB = iNMB,
                          n_patients_current = n_patients_current,
                          n_patients_future = n_patients_future)
  
  v_enb_AWR<- calc_enb_AWR(iNB = iNMB,
                                    rct_ratio = n_p_rct_ratio,
                                    sample_size = n_samp_size,
                                    EVPSI = EVPSI,
                                    n_patients_current = n_patients_current,
                                    n_patients_future = n_patients_future,
                                    c_RCT_fixed = c_RCT_fixed,
                                    c_RCT_pp = c_RCT_ppo)
   df_enb["AWR",   n] <- v_enb_AWR[which.max(v_enb_AWR)]
    

  if(oss > 0){ 
    df_enb["Optimal strategy", n]         <- "OIR"   # store the strategy       
    #df_enb["OIR", n]                      <- v_enb_OIR[which.max(v_enb_OIR)]
    df_enb["Optimal sample size (N*)", n] <- oss
    df_enb["Costs RCT", n]                <- round((c_RCT_fixed + oss  * c_RCT_ppo)) 
    df_enb["EVSI N*", n]                 <- round(EVPSI[which(names(EVPSI) == oss)])
    
}  else {
      df_enb["Optimal strategy", n] <- "Reject"   # store the strategy 
      df_enb["Reject", n] <- 0
      #df_enb["OIR", n]                      <- v_enb_OIR[which.max(v_enb_OIR)]
      
      #df_enb["OIR", n]    <- "Worse than Reject" # If you decided OIR, it costs you a lot of money
}
  
  if(oss > 2500){
        df_enb["EVSI N=2500", n]   <- round(EVPSI[which(names(EVPSI) == n_samp_size_real)])
    df_enb["Costs RCT N=2500", n]   <- round((c_RCT_fixed + n_samp_size_real * c_RCT_ppo)) 
  
    df_enb["OIR N=2500",   n]  <- calc_enb_OIR(iNB = iNMB, 
                                    rct_ratio = n_p_rct_ratio, 
                              sample_size = n_samp_size_real, 
                              EVPSI =  EVPSI[which(names(EVPSI) == n_samp_size_real)], 
                              n_patients_future = n_patients_future, 
                              c_RCT_fixed = c_RCT_fixed, 
                              c_RCT_pp = c_RCT_ppo)
    
    df_enb["AWR N=2500",   n] <- calc_enb_AWR(iNB = iNMB,
                                    rct_ratio = n_p_rct_ratio,
                                    sample_size = n_samp_size_real,
                                    EVPSI = EVPSI[which(names(EVPSI) == n_samp_size_real)],
                                    n_patients_current = n_patients_current,
                                    n_patients_future = n_patients_future,
                                    c_RCT_fixed = c_RCT_fixed,
                                    c_RCT_pp = c_RCT_ppo)

  }
    
      
  l_enb[[n]] <- data.frame(N     = n_samp_size, 
                           Study = "RCT",
                            cRCT = round((c_RCT_fixed + oss * c_RCT_ppo)),
                            EVPSI = round(EVPSI),
                  Implementation = "OIR",
                           ENB   = v_enb_OIR,
                           nstar = oss,
                        ENBnstar = v_enb_OIR[which.max(v_enb_OIR)]) 

  
  
  
} else if(iNMB > 0 & EVPPI > 0){
  
    EVPSI        <- l_pop_evpsi_rct_r[[n]]$EVPSI # select EVPSI per person
    names(EVPSI) <- l_pop_evpsi_rct_r[[n]]$N
  
    v_enb_AWR <-  calc_enb_AWR(iNB = iNMB,
                                    rct_ratio = n_p_rct_ratio,
                                    sample_size = n_samp_size,
                                    EVPSI = EVPSI,
                                    n_patients_current = n_patients_current,
                                    n_patients_future = n_patients_future,
                                    c_RCT_fixed = c_RCT_fixed,
                                    c_RCT_pp = c_RCT_ppo)
    oss <- n_samp_size[which.max(v_enb_AWR)] 
    
    df_enb["AWR", n]  <- round(v_enb_AWR[which.max(v_enb_AWR)]) 
    
    # Calculate only in research 
    v_enb_OIR <- calc_enb_OIR(iNB = iNMB, 
                              rct_ratio = n_p_rct_ratio, 
                              sample_size = n_samp_size, 
                              EVPSI = EVPSI, 
                              n_patients_future = n_patients_future, 
                              c_RCT_fixed = c_RCT_fixed, 
                              c_RCT_pp = c_RCT_ppo)
  
    df_enb["OIR", n] <- v_enb_OIR[which.max(v_enb_OIR)]

    l_enb[[n]] <- data.frame(N   = n_samp_size, 
                             Study = "RCT",
                             cRCT = round((c_RCT_fixed + oss * c_RCT_ppo)),
                             EVPSI = EVPSI,
                             Implementation = "AWR",
                             ENB = v_enb_AWR,
                             nstar = oss)


  # Calculate the expected net value for approve
  df_enb["Approve", n] <- calc_enb_approve(iNB = iNMB,
                                           n_patients_current = n_patients_current,
                                           n_patients_future = n_patients_future)
      
    if(df_enb["AWR", n] > df_enb["Approve", n]){ 
      df_enb["Optimal strategy", n]    <- "AWR"   # store the strategy     
      df_enb["AWR", n]                 <- round(v_enb_AWR[which.max(v_enb_AWR)]) 
      df_enb["Optimal sample size (N*)", n] <- oss
      df_enb["Costs RCT", n]           <- round((c_RCT_fixed + oss * c_RCT_ppo))     
      df_enb["EVSI N*", n]            <- round(EVPSI[which(names(EVPSI) == oss)])

}  else{
      df_enb["Optimal strategy", n] <- "Approve"   # store the strategy 
      df_enb["AWR", n]              <- round(v_enb_AWR[which.max(v_enb_AWR)]) 
       # Calculate the expected net value for approve
       df_enb["Approve", n]         <- calc_enb_approve(iNB = iNMB,
                                           n_patients_current = n_patients_current,
                                           n_patients_future = n_patients_future)
}
  if(oss > 2500){
          
      df_enb["Costs RCT N=2500", n]    <- round((c_RCT_fixed + 2500 * c_RCT_ppo))
      df_enb["EVSI N=2500", n]        <- round(EVPSI[which(names(EVPSI) == 2500)])
      df_enb["AWR N=2500", n]          <- calc_enb_AWR(iNB = iNMB,
                                                  rct_ratio = n_p_rct_ratio,
                                                  sample_size = 2500,
                                                  EVPSI = EVPSI[which(names(EVPSI) == 2500)],
                                                  n_patients_current = n_patients_current,
                                                  n_patients_future = n_patients_future,
                                                  c_RCT_fixed = c_RCT_fixed,
                                                  c_RCT_pp = c_RCT_ppo)
      
          
    df_enb["OIR N=2500",   n]  <- calc_enb_OIR(iNB = iNMB, 
                                         rct_ratio = n_p_rct_ratio, 
                                       sample_size = 2500, 
                                             EVPSI =  EVPSI[which(names(EVPSI) == 2500)], 
                                 n_patients_future = n_patients_future, 
                                      c_RCT_fixed = c_RCT_fixed, 
                                         c_RCT_pp = c_RCT_ppo)
  }
}

}


save(df_enb, file = "../output/df_enb_LY.rda")


# Note only done for the studies that show positive EVPPI
df_oss <- matrix(NA, nrow = 3, ncol = length(names(l_enb)), 
                 dimnames = list(c("Implementation", "MaxENBS", "Nstar"), names(l_enb)))


for (n in names(l_enb)){
#### Optimal Sample Size (OSS), n*
l_oss[[n]] <- summarise(group_by(l_enb[[n]], Study),
                        Implementation = Implementation[1],
                      MaxENBS = max(ENB),
                      Nstar   = N[which.max(ENB)])

df_oss[, n] <- t(l_oss[[n]]) # transpose the data and store in a dataframe
}


df_enb_plot <- df_enb
colnames(df_enb_plot) <- remove_date_from_name(colnames(df_enb_plot))

# New order table 
df_enb_plot_order <- df_enb_plot[, c(which(df_enb_plot["Optimal strategy", ] == "OIR"),
which(df_enb_plot["Optimal strategy", ] == "AWR"),
which(df_enb_plot["Optimal strategy", ] == "Approve"),
which(df_enb_plot["Optimal strategy", ] == "Reject"))]


df_enb_plot[is.na(df_enb_plot)] <- "n/a"
png("../figures/table_enb_LY.png", width = 1200, height = 600, bg = "white", pointsize = 22)
grid.table(df_enb_plot_order)
dev.off()


save(l_enb,       file = "../output/l_enb_LY.rda")
save(df_enb,      file = "../output/df_enb_LY.rda")
save(df_enb_plot, file = "../output/df_enb_plot_LY.rda")


l_enb_LY <- l_enb
df_enb_LY <- df_enb
df_enb_plot_LY <- df_enb_plot
```


### 9.6.7 Plot Net value
```{r}

l_enb <- l_enb_LY

for (n in names(l_enb)){
ggplot(l_enb[[n]], aes(x = N, y = (ENB/1e6))) +
  geom_line() +
  xlab("Sample size") +
  ylab("ENB (Million $)") + 
  ggtitle(paste("ENB of", remove_date_from_name(n), "for strategy:", seb = ""),
          subtitle = l_enb[[n]]$Implementation[1]) +
  geom_vline(xintercept = mean(l_enb[[n]]$nstar), linetype = "dashed", 
                color = "gray", size = 0.8) +
        labs(caption = paste("ENB at N=2500:", round(mean(l_enb[[n]]$ENB[l_enb[[n]]$N == 2500]/1e6)), "and ENB at N*:", round(l_enb[[n]]$nstar/1e6), sep =" "), colour = "lightblue")
    
  
  
    #  geom_vline(xintercept = mean(l_enb[[n]]$ENB[l_enb[[n]]$N == 2500]), linetype = "dashed", 
     #           color = "lightblue", size = 0.8) +
    #theme(plot.caption=element_text(margin = margin(t = 15),
                                       # face = "italic", size = 15, colour = "darkgrey")) 
  #    geom_text(x = mean(l_enb[[n]]$nstar), 
        #      y = mean(l_enb[[n]]$ENB)/1e6, 
         #     label = paste("Optimal sample size (N*):", mean(l_enb[[n]]$nstar))) 

        ggsave(path = here("../figures"), filename = paste("ENB_LY", "_", remove_date_from_name(n), ".png", sep =""))  # save the plot
}


l_enb <- l_enb_QALY

for (n in names(l_enb)){
  
 ggplot(l_enb[[n]], aes(x = N, y = (ENB/1e6))) +
  geom_line() +
  xlab("Sample size") +
  ylab("ENB (Million $)") + 
  ggtitle(paste("ENB of", remove_date_from_name(n), "for strategy:", seb = ""),
          subtitle = l_enb[[n]]$Implementation[1]) +
  geom_vline(xintercept = mean(l_enb[[n]]$nstar), linetype = "dashed", 
                color = "gray", size = 0.8) +
        labs(caption = paste("ENB at N=2500:", round(mean(l_enb[[n]]$ENB[l_enb[[n]]$N == 2500]/1e6)), "and ENB at N*:", round(l_enb[[n]]$nstar/1e6), sep =" "), colour = "lightblue")
    
    
        ggsave(path = here("../figures"), filename = paste("ENB_QALY", "_", remove_date_from_name(n), ".png", sep =""))  # save the plot
}

```



#10. Summary of results
##10.1 Update the summary table QALY
```{r}
#load(file = "../output/df_summary_cea_QALY_PSA_report.rda")
#load(file = "../output/df_enb_plot.rda")

options(scipen = 999)

# Select the columns for the report
# Check if all the column names in the structures are identical. If so, merge the data


df_enb_plot <- df_enb_plot_QALY
  
df_enb_plot_order <- df_enb_plot[match(rownames(df_summary_cea_QALY_PSA_report), colnames(df_enb_plot))]


if(all(rownames(df_summary_cea_QALY_PSA_report) == colnames(df_enb_plot_order))){
  m_summary_results_new <- rbind(t(df_summary_cea_QALY_PSA_report), df_enb_plot_order)}


df_summary_results <- as.data.frame(m_summary_results_new)
save(df_summary_results, file = "../output/df_summary_results.rda")


# New order table 
df_summary_results_order <- df_summary_results[, c(which(df_summary_results["Optimal strategy", ] == "OIR"),
which(df_summary_results["Optimal strategy", ] == "AWR"),
which(df_summary_results["Optimal strategy", ] == "Approve"),
which(df_summary_results["Optimal strategy", ] == "Reject"))]



df_summary_results_format <- df_summary_results_order

df_summary_results_format[is.na(df_summary_results_format)] <- "n/a"
png("../figures/table_summary_results.png", width =1200, height = 800, bg = "white", pointsize = 22)
grid.table(df_summary_results_format)
dev.off()


df_summary_results_transposed <- as.data.frame(t(m_summary_results_new))

png("../figures/table_summary_results_tranposed.png", width = 3200, height = 500, bg = "white", pointsize = 22)
grid.table(df_summary_results_transposed)
dev.off()



df_summary_results_round <- format_table_final(df_summary_results, 
                   v_thousand = c("Future patients", "Current patients"),
                   v_million  = c("EVPPI", "Costs RCT", "AWR", "OIR", "Costs RCT N=2500", "OIR N=2500", "AWR N=2500", "Approve"),
                   integer = FALSE)

df_summary_results_round_format <- df_summary_results_round
df_summary_results_round_format[is.na(df_summary_results_round_format)] <- "n/a"
  

png("../figures/table_summary_results_rounded.png", width = 1300, height = 800, bg = "white", pointsize = 22)
grid.table(df_summary_results_round_format)
dev.off()



df_summary_results_round <- format_table_final(df_summary_results, 
                   v_thousand = c("Future patients", "Current patients"),
                   v_million  = c("EVPPI", "Costs RCT", "AWR", "OIR", "Costs RCT N=2500", "OIR N=2500", "AWR N=2500", "Approve"),
                   integer = TRUE)

df_summary_results_round_format_integer <- df_summary_results_round
df_summary_results_round_format_integer[is.na(df_summary_results_round_format_integer)] <- "n/a"
  

png("../figures/table_summary_results_integer.png", width = 1300, height = 800, bg = "white", pointsize = 22)
grid.table(df_summary_results_round_format_integer)
dev.off()


```


###10.1.1 Table formatted for the paper
```{r}
df_table_tem <- df_summary_results
df_table1 <- df_table_tem[1:10, ]


for(s in c("OIR", "AWR","Approve", "Reject")){
df_table1["Net value", df_table_tem["Optimal strategy", ] == s] <-  df_table_tem[s, df_table_tem["Optimal strategy", ] == s] 
}

df_table1_formatted <- format_table_final(df_table1, 
                                        v_thousand  = c("Future patients", 
                                                        "Current patients", 
                                                        "Incremental net monetary benefit ($)"),
                                        v_million    = c("Net value", "EVPPI"),
                                          v_round   = c("Incremental Costs ($)",
                                                        "Future patients", 
                                                        "Current patients"),
                                        integer = FALSE)
df_table1_formatted

df_table1_formatted[is.na(df_table1_formatted)] <- "n/a"



# New order table 
df_table1_formatted_order <- df_table1_formatted[, c(which(df_table1_formatted["Optimal strategy", ] == "OIR"),
which(df_table1_formatted["Optimal strategy", ] == "AWR"),
which(df_table1_formatted["Optimal strategy", ] == "Approve"),
which(df_table1_formatted["Optimal strategy", ] == "Reject"))]


png("../figures/table_table1_annex.png", width = 1200, height = 300, bg = "white", pointsize = 22)
grid.table(df_table1_formatted_order)
dev.off()




#### Also make an integer version of it

df_table1_formatted_integer <- format_table_final(df_table1, 
                                        v_thousand  = c("Future patients", 
                                                        "Current patients", 
                                                        "Incremental net monetary benefit ($)"),
                                        v_million   = c("Net value", "EVPPI"),
                                          v_round   = c("Incremental Costs ($)",
                                                        "Future patients", 
                                                        "Current patients"),
                                        integer = TRUE)
df_table1_formatted_integer

df_table1_formatted_integer[is.na(df_table1_formatted_integer)] <- "n/a"



# New order table 
df_table1_formatted_integer <- df_table1_formatted_integer[, c(which(df_table1_formatted_integer["Optimal strategy", ] == "OIR"),
which(df_table1_formatted_integer["Optimal strategy", ] == "AWR"),
which(df_table1_formatted_integer["Optimal strategy", ] == "Approve"),
which(df_table1_formatted_integer["Optimal strategy", ] == "Reject"))]


png("../figures/table_table1_annex.png", width = 1200, height = 300, bg = "white", pointsize = 22)
grid.table(df_table1_formatted_integer)
dev.off()

```


##10.2 Update the summary table LY
```{r}
#load(file = "../output/df_summary_cea_QALY_PSA_report.rda")
#load(file = "../output/df_enb_plot.rda")

options(scipen = 999)

# Select the columns for the report
# Check if all the column names in the structures are identical. If so, merge the data


df_enb_plot <- df_enb_plot_LY
  
df_enb_plot_order <- df_enb_plot[match(rownames(df_summary_cea_LY_PSA_report), colnames(df_enb_plot))]


if(all(rownames(df_summary_cea_LY_PSA_report) == colnames(df_enb_plot_order))){
  m_summary_results_new <- rbind(t(df_summary_cea_LY_PSA_report), df_enb_plot_order)}


df_summary_results <- as.data.frame(m_summary_results_new)
save(df_summary_results, file = "../output/df_summary_results_LY.rda")


# New order table 
df_summary_results_order <- df_summary_results[, c(which(df_summary_results["Optimal strategy", ] == "OIR"),
which(df_summary_results["Optimal strategy", ] == "AWR"),
which(df_summary_results["Optimal strategy", ] == "Approve"),
which(df_summary_results["Optimal strategy", ] == "Reject"))]



df_summary_results_format <- df_summary_results_order

df_summary_results_format[is.na(df_summary_results_format)] <- "n/a"
png("../figures/table_summary_results_LY.png", width =1200, height = 800, bg = "white", pointsize = 22)
grid.table(df_summary_results_format)
dev.off()


df_summary_results_transposed <- as.data.frame(t(m_summary_results_new))

png("../figures/table_summary_results_tranposed_LY.png", width = 3200, height = 500, bg = "white", pointsize = 22)
grid.table(df_summary_results_transposed)
dev.off()



df_summary_results_round <- format_table_final(df_summary_results, 
                   v_thousand = c("Future patients", "Current patients"),
                   v_million  = c("EVPPI", "Costs RCT", "AWR", "OIR", "Costs RCT N=2500", "OIR N=2500", "AWR N=2500", "Approve"),
                   integer = FALSE)

df_summary_results_round_format <- df_summary_results_round
df_summary_results_round_format[is.na(df_summary_results_round_format)] <- "n/a"
  

png("../figures/table_summary_results_rounded_LY.png", width = 1300, height = 800, bg = "white", pointsize = 22)
grid.table(df_summary_results_round_format)
dev.off()



df_summary_results_round <- format_table_final(df_summary_results, 
                   v_thousand = c("Future patients", "Current patients"),
                   v_million  = c("EVPPI", "Costs RCT", "AWR", "OIR", "Costs RCT N=2500", "OIR N=2500", "AWR N=2500", "Approve"),
                   integer = TRUE)

df_summary_results_round_format_integer <- df_summary_results_round
df_summary_results_round_format_integer[is.na(df_summary_results_round_format_integer)] <- "n/a"
  

png("../figures/table_summary_results_integer_LY.png", width = 1300, height = 800, bg = "white", pointsize = 22)
grid.table(df_summary_results_round_format_integer)
dev.off()


```


###10.2.1 Table formatted for the paper
```{r}
df_table_tem <- df_summary_results
df_table1 <- df_table_tem[1:10, ]


for(s in c("OIR", "AWR","Approve", "Reject")){
df_table1["Net value", df_table_tem["Optimal strategy", ] == s] <-  df_table_tem[s, df_table_tem["Optimal strategy", ] == s] 
}

df_table1_formatted <- format_table_final(df_table1, 
                                        v_thousand  = c("Future patients", 
                                                        "Current patients", 
                                                        "Incremental net monetary benefit ($)"),
                                        v_million   = c("Net value", "EVPPI"),
                                          v_round   = c("Incremental Costs ($)",
                                                        "Future patients", 
                                                        "Current patients"),
                                        integer = FALSE)
df_table1_formatted

df_table1_formatted[is.na(df_table1_formatted)] <- "n/a"



# New order table 
df_table1_formatted_order <- df_table1_formatted[, c(which(df_table1_formatted["Optimal strategy", ] == "OIR"),
which(df_table1_formatted["Optimal strategy", ] == "AWR"),
which(df_table1_formatted["Optimal strategy", ] == "Approve"),
which(df_table1_formatted["Optimal strategy", ] == "Reject"))]


png("../figures/table_table1_annex_LY.png", width = 1200, height = 300, bg = "white", pointsize = 22)
grid.table(df_table1_formatted_order)
dev.off()




#### Also make an integer version of it

df_table1_formatted_integer <- format_table_final(df_table1, 
                                        v_thousand  = c("Future patients", 
                                                        "Current patients", 
                                                        "Incremental net monetary benefit ($)"),
                                        v_million   = c("Net value", "EVPPI"),
                                          v_round   = c("Incremental Costs ($)",
                                                        "Future patients", 
                                                        "Current patients"),
                                        integer = TRUE)
df_table1_formatted_integer

df_table1_formatted_integer[is.na(df_table1_formatted_integer)] <- "n/a"



# New order table 
df_table1_formatted_integer <- df_table1_formatted_integer[, c(which(df_table1_formatted_integer["Optimal strategy", ] == "OIR"),
which(df_table1_formatted_integer["Optimal strategy", ] == "AWR"),
which(df_table1_formatted_integer["Optimal strategy", ] == "Approve"),
which(df_table1_formatted_integer["Optimal strategy", ] == "Reject"))]


png("../figures/table_table1_annex_LY.png", width = 1200, height = 300, bg = "white", pointsize = 22)
grid.table(df_table1_formatted_integer)
dev.off()

```



```{r}
print("ready")
```

# Acknowlegdement
For this research we made use of the template developed by the Decision Analysis in R for Technologies in Health (DARTH) workgroup: <http://darthworkgroup.com>.

The notation of our code is based on the following provided framework and coding convention:
Alarid-Escudero, F., Krijkamp, E., Pechlivanoglou, P. et al. A Need for Change! A Coding Framework for Improving Transparency in Decision Modeling. PharmacoEconomics 37, 13291339 (2019). <https://doi.org/10.1007/s40273-019-00837-x>.

This work is supported by the SMDM CDMI grand from the Gordon and Betty Moore Foundation.

