shiny::runApp()
shiny::runApp()
# Load the packages
library(shiny)
library(shinythemes)
library(shinyWidgets)
library(shinyjs)
library(lubridate)
library(rsconnect)
library(shinyBS)
# use this package to conveniently install other packages
p_load("matrixStats", "ggplot2",
"scales", "reshape2",
"nlme", "mgcv", "BCEA",
"inlabru", "devtools",
"tibble", "tidyverse", "ggpubr",
"rms", "europepmc", "Rmisc",
"fmsb", "remotes", "readxl", "plyr", "stats", "triangle",
"EnvStats", "e1071", "meta","metafor", "gridExtra",
"here", "dplyr","ellipse", "ggplot2", "lazyeval",
"igraph", "ggraph","knitr", "plyr", "stats", "diagram",
"triangle", "HMDHFDplus", "blscrapeR", "here", "gridExtra", "foreach", "mondate")
# use this package to conveniently install other packages
library("matrixStats", "ggplot2",
"scales", "reshape2",
"nlme", "mgcv", "BCEA",
"inlabru", "devtools",
"tibble", "tidyverse", "ggpubr",
"rms", "europepmc", "Rmisc",
"fmsb", "remotes", "readxl", "plyr", "stats", "triangle",
"EnvStats", "e1071", "meta","metafor", "gridExtra",
"here", "dplyr","ellipse", "ggplot2", "lazyeval",
"igraph", "ggraph","knitr", "plyr", "stats", "diagram",
"triangle", "HMDHFDplus", "blscrapeR", "here", "gridExtra", "foreach", "mondate")
# use this package to conveniently install other packages
packages_to_instal <- c("matrixStats", "ggplot2",
"scales", "reshape2",
"nlme", "mgcv", "BCEA",
"inlabru", "devtools",
"tibble", "tidyverse", "ggpubr",
"rms", "europepmc", "Rmisc",
"fmsb", "remotes", "readxl", "plyr", "stats", "triangle",
"EnvStats", "e1071", "meta","metafor", "gridExtra",
"here", "dplyr","ellipse", "ggplot2", "lazyeval",
"igraph", "ggraph","knitr", "plyr", "stats", "diagram",
"triangle", "HMDHFDplus", "blscrapeR", "here", "gridExtra", "foreach", "mondate")
lapply(packages_to_instal, library, character.only = TRUE)
lapply(packages_to_load, library, character.only = TRUE)
# use this package to conveniently install other packages
packages_to_load <- c("matrixStats", "ggplot2",
"scales", "reshape2",
"nlme", "mgcv", "BCEA",
"inlabru", "devtools",
"tibble", "tidyverse", "ggpubr",
"rms", "europepmc", "Rmisc",
"fmsb", "remotes", "readxl", "plyr", "stats", "triangle",
"EnvStats", "e1071", "meta","metafor", "gridExtra",
"here", "dplyr","ellipse", "ggplot2", "lazyeval",
"igraph", "ggraph","knitr", "plyr", "stats", "diagram",
"triangle", "HMDHFDplus", "blscrapeR", "here", "gridExtra", "foreach", "mondate")
lapply(packages_to_load, library, character.only = TRUE)
p_load_gh("DARTH-git/dampack") # coding framework to construct model-based cost-effectiveness analysis in R
#p_load_gh("DARTH-git/darthpack") # package for analyzing and visualizing the health economic outputs of mathematical models
library("darthtools") # a R package that contains tools frequently used by the DARTH workgroup
runApp()
version
runApp('test')
runApp('test')
runApp('test')
runApp('test')
shiny::runApp('test')
runApp('test')
runApp('test')
runApp('test')
runApp('test')
shiny::runApp()
runApp()
runApp()
runApp()
runApp('~/Documents/GitHub/Emerging-Therapies-for-COVID-19')
runApp('~/Documents/GitHub/Emerging-Therapies-for-COVID-19')
hist(100)
shiny::runApp('test')
data <- 1:1e9
data_list <- list("1" = data,
"2" = data,
"3" = data,
"4" = data)
# Detect the number of available cores and create cluster
cl <- parallel::makeCluster(detectCores())
# Run parallel computation
time_parallel <- system.time(
parallel::parLapply(cl,
data_list,
mean)
)
# Close cluster
parallel::stopCluster(cl)
time_parallel
runApp('test')
output$textParallel <- renderText({
# Generate data
data <- 1:1e9
data_list <- list("1" = data,
"2" = data,
"3" = data,
"4" = data)
# Detect the number of available cores and create cluster
cl <- parallel::makeCluster(detectCores())
# Run parallel computation
time_parallel <- system.time(
parallel::parLapply(cl,
data_list,
mean)
)
# Close cluster
parallel::stopCluster(cl)
time_parallel
})
as.table(time_parallel)
time_parallel
runApp('test')
shiny::runApp('test')
data <- 1:1e3
data_list <- list("1" = data,
"2" = data,
"3" = data,
"4" = data)
# Detect the number of available cores and create cluster
cl <- parallel::makeCluster(detectCores())
# Activate cluster for foreach library
doParallel::registerDoParallel(cl)
time_foreach <- system.time({
r <- foreach::foreach(i = 1:length(data_list),
.combine = rbind) %dopar% {
mean(data_list[[i]])
}
})
time_foreach[3]
# Stop cluster to free up resources
parallel::stopCluster(cl)
r
runApp('test')
hist(r[,1])
runApp('test')
runApp('test')
runApp('test')
runApp('test')
runApp('test')
runApp('test')
runApp('test')
runApp('test')
runApp('test')
runApp('test/app_with parallel.R')
View(r)
1:1e2
runApp('test/app_with parallel.R')
runApp('test/app_with parallel.R')
runApp('test/app_with parallel.R')
library(shiny); runApp('~/Desktop/testshiny.R')
runApp('~/Desktop/test/testshiny.R')
runApp('~/Desktop/test/testshiny.R')
